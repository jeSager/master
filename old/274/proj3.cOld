#include "timer.h"
#include "cmod.h"
#include "iroblib.h"
#include "oi.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// Declare Global variables 

uint8_t true=1;
uint8_t false=0;
uint8_t right=1; // Boolean for turning
uint8_t left=0; // Boolean for turning
uint8_t start=0;//try to drive straight boolean
uint8_t docking=0;

uint8_t sensors[Sen6Size]; // Array for all sensor data the robot can send
uint16_t state;//[10];
uint8_t SETPOINT=80;

uint8_t drivingStraight=0;
// PID Values
uint8_t P; // Proportional term
uint8_t I; // Integral term
uint8_t D; // Derivative term
int8_t U; // Control signal
uint8_t PGain=80; // Proportional gain
uint8_t IGain=20; // Integral gain
uint8_t DGain=200; // Derivative gain
uint8_t PROPORTIONAL4U=100;//given proportion
uint8_t T=1; // Delta t (1ms)
uint16_t sum; // Summation for I term
uint8_t e[10]; // Error array

// Wheel adjustments
uint16_t wheelSpeed;
uint16_t newSpeed;
uint8_t highBit;   
uint8_t lowBit;
uint16_t leftSpeed;
uint8_t highBitLeft;
uint8_t lowBitLeft;

// functions
int main(void);
void printBuffer(char buf[]);
void rotate(uint8_t r, uint8_t d);
void driveToWall(void);
void stop(void);
void alignWall(void);
void followWall(void);
void home(void);
void faceHome(uint8_t r);
void driveStraightHome(void);
void dock(void);
void robotStateSelector(void);

//LEDS
void setupLEDs(void);
void rightLEDon(void);
void rightLEDoff(void); 
void leftLEDon(void); 
void leftLEDoff(void);
void bothLEDon(void);
void bothLEDoff(void);






int main(void) {
// Set up Create and module
initializeCommandModule();

powerOnRobot();
// Is the Robot on
byteTx(CmdStart);
// Start the create
baud(Baud57600);
// Set the baud rate for the Create and Command Module
defineSongs();
// Define some songs so that we know the robot is on.
byteTx(CmdControl);
// Deprecated form of safe mode. I use it because it will
// turn of all LEDs, so it's essentially a reset.
byteTx(CmdFull);
// We are operating in FULL mode.

// CSCE 274 students: I would make sure the robot stops. 
//                    As a precaution for the robot and your grade.

// Play the reset song and wait while it plays.
byteTx(CmdPlay);
byteTx(RESET_SONG);
delayMs(750);

// Turn the power button on to something. I like red, but here is green.
// CSCE 274 students: The following should (will) be a function that you write.
byteTx(CmdLeds);
byteTx(0x00);
byteTx(0);
byteTx(255);

//populate the error array
for(int i=0;i<9;i++) 
	e[i]=0;

// Infinite operation loop
for(;;) {

if(canSense){

	 // Using timer 0 to continuously update the sensor array
	uint8_t i;
	while(UCSR0A & 0x80)
	i = UDR0;
	byteTx(CmdSensors);  // Sensor opcode 
	byteTx(6);   // Send request for packet 0 
	for(uint8_t i = 0; i < Sen6Size; i++) // Read each sensor byte
		sensors[i] = byteRx();
	for (int i=0;i<9;i++) 
		state=sensors[SenWallSig1] << 8 | sensors[SenWallSig0];//[i]

	senseTimerCount=100;
	canSense=0;
	//////////////////end timing

	//robot goes straight first, state intialized to zero
	robotStateSelector();

	/////////////////PID CONTROL
	sum=0;
	//dump index zero and bump all values down
	for(int j=0;j<8;j++){
		e[j]=e[j+1];
		sum=sum+e[j];
	}
	//we've made room for the current data
	//finish i summation
	e[9]=SETPOINT-state;
	sum=sum+e[9];

	//use the array to complete the formula
	P=PGain*e[9];
	I=IGain*sum*T;
	D=DGain*((e[9]-e[8])/T);
	U=(P+I+D)/PROPORTIONAL4U;

}//end if (canSense)

delayMs(15);
if(UserButtonPressed) {
	powerOffRobot();
	exit(1);
	}//endif
}//endInfinateFor
}//////////////////////////////////////////////////////////////////////end main

void stop(void) {
	byteTx(CmdDriveWheels);
	byteTx(0x00);//velocity right wheel 0mm/s
	byteTx(0x00);
	byteTx(0x00);//velocity left wheel 0mm/s
	byteTx(0x00);

}//////////////////////////////////////////////////////////////////////////////

void rotate(uint8_t r, uint8_t degree){
	int rotateDelayMs = degree*8;//gives proper degree at 30cm/s
	byteTx(CmdDriveWheels);
	if(r){
	byteTx(0xfe);//velocity right wheel 
	byteTx(0xd4);
	byteTx(0x01);//velocity left wheel 
	byteTx(0x2c);
	}
	else{	
	byteTx(0x01);//velocity right wheel 
	byteTx(0x2c);
	byteTx(0xfe);//velocity left wheel 
	byteTx(0xd4);
	}
	delayMs(rotateDelayMs);


}//////////////////////////////////////////////////////////////////////////////
void driveToWall(void){
	byteTx(CmdDriveWheels);
	byteTx(0x00);//velocity right wheel
	byteTx(0x40);
	byteTx(0x00);//velocity left wheel
	byteTx(0x70);	
	start=(sensors[SenBumpDrop]==1 || sensors[SenBumpDrop]==2 || sensors[SenBumpDrop]==3);

}//////////////////////////////////////////////////////////////////////////////
void driveStraightHome(void){
    byteTx(CmdDriveWheels);
    byteTx(0x00); // Velocity right wheel 
    byteTx(0x40);
    byteTx(0x00); // Velocity left wheel 
    byteTx(0x40);

}//////////////////////////////////////////////////////////////////////////////
void faceHome(uint8_t r){
    byteTx(CmdDriveWheels);
    if(r){
        byteTx(0x00); // Velocity right wheel 
        byteTx(0x70);
        byteTx(0x00); // Velocity left wheel 
        byteTx(0x40);
    }
    else{
        byteTx(0x00); // Velocity left wheel 
        byteTx(0x40);
        byteTx(0x00); // Velocity right wheel 
        byteTx(0x70);
	}

}//////////////////////////////////////////////////////////////////////////////
void followWall(void) {
	wheelSpeed=0x96;
	leftSpeed=wheelSpeed-U;//16bit
	highBitLeft=leftSpeed>>8;
	lowBitLeft=leftSpeed-(highBitLeft<<8);
	newSpeed=wheelSpeed+U;//16bit
	highBit=newSpeed>>8;   
	lowBit=newSpeed-(highBit<<8);
	byteTx(CmdDriveWheels);
	byteTx(highBit);//velocity right wheel 150mm/s+u
	byteTx(lowBit);
	//left stays constant
	byteTx(highBitLeft);//velocity left wheel 150mm/s
	byteTx(lowBitLeft);

}//////////////////////////////////////////////////////////////////////////////
void dock(){
		
	docking=true;
	for(int i=0;i<3;i++){//try this three times
		stop();			
		delayMs(5000);
		if(sensors[SenChAvailable]==2){while(true)stop();}// for charging mode		
		rotate(right, 5);
		stop();
		delayMs(5000);
		if(sensors[SenChAvailable]==2){while(true)stop();}// for charging mode		
		rotate(left, 10);
		stop();
		delayMs(5000);
		if(sensors[SenChAvailable]==2){while(true)stop();}// for charging mode

		byteTx(CmdDriveWheels);
		byteTx(0xff); //backwards
		byteTx(0x06);
		byteTx(0xff); 
		byteTx(0x06);
		delayMs(350);
		
		robotStateSelector();
	}
	rotate(right, 180);
	start=false;//restart the entire algorithm
	docking=false;
	main();	

}//////////////////////////////////////////////////////////////////////////////
void home(void) {
	//initialize IR vars

	//uint8_t reserved= (sensors[SenIRChar]==240);//not used?
	uint8_t force= (sensors[SenIRChar]==242);
	uint8_t red= (sensors[SenIRChar]==248);
	uint8_t green= (sensors[SenIRChar]==244);
	uint8_t redgreen= (sensors[SenIRChar]==252);
	uint8_t redgreenforce= (sensors[SenIRChar]==254);
	uint8_t greenforce= (sensors[SenIRChar]==246);
	uint8_t redforce= (sensors[SenIRChar]==250);

	//!docking because we cannot dock while we're docking
	if(sensors[SenBumpDrop]>0&&!docking){
		if((sensors[SenIRChar]>241)&&(sensors[SenIRChar]<255))
			dock();
	}
	else if(redgreen||redgreenforce){
		driveStraightHome();
		bothLEDon();		
	}
	else if(red||redforce){
		faceHome(right);
		rightLEDon();
	}
	else if(green||greenforce){
		faceHome(left);
		leftLEDon();
	}

}//////////////////////////////////////////////////////////////////////////////
void robotStateSelector(void){
	bothLEDoff();//led shows how algorithm is affecting controler

	//infinate stop if charging
	if(sensors[SenChAvailable]==2){while(true)stop();}//charging mode

	//operation mode implies wheels are on the ground
	else if(sensors[SenBumpDrop]<=4) {
	
		//if wall has been found, try to dock
		if (start)//&&sensors[SenIRChar]!=255)//Docking station signal detected
			home();

		// If wall reading and no bumper, then robot should align/follow wall
		else if (state>=6 && sensors[SenBumpDrop]==0){ 
			start=true;		
			followWall();// Aligned with wall (follow)
		}

		// If no wall reading and no bumper, robot should look for a wall
		else if (sensors[SenBumpDrop]==0 && state<=5) 
			driveToWall();

		// Otherwise, robot is against the wall and needs to rotate to keep moving
		else
			rotate(left, false);
	} // end wheel drop detection
	else
		stop();//implies wheels are off the ground

}//////////////////////////////////////////////////////////////////////////////
void setupLEDs(void) {DDRD |= 0X60;}
void rightLEDon(void) {PORTD &= ~0x20;}
void rightLEDoff(void) {PORTD |= 0x20;}
void leftLEDon(void) {PORTD &= ~0x40;}
void leftLEDoff(void) {PORTD |= 0x40;}
void bothLEDon(void) {rightLEDon();leftLEDon();}
void bothLEDoff(void) {rightLEDoff();leftLEDoff();}


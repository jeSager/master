
make this function in the node file
bool zeroIncoming()

make this function in the graph file
bool acyclic



Set incoming vectors:

vector<int> children
for n in graph
  children=n.getChildSubs();
  for c in children
    c.IncrementIncoming();

--done--

ascylic = testCyclic( graph, false )

bool testCyclic( vector<int> test, bool acyclic){

for n in testgraph{

  if n.noChild && n.hasIncoming

    // remove leaf ref
    for any in testgraph
      for c in any.children
        if n==c
          any.removeChild

     // remove the leaf
     testgraph.pop(n)
     if( testgraph(empty)) acyclic=true;
     else testCyclic(testgraph, acyclic)
}
return acyclic;

stack<Node> stack

for n in graph
  acyclic=n.HasNotBeenVisited();
  if (n.zeroIncoming() && acyclic)
    stack.push(n);
  while( acyclic &&  ! stack.empty() )
    for p in path & ! acyclic
      if( p == stack.top().getnodenumber() )
          acyclic == false
    if( asyclic )\


###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################


// For topological sorting to be possible,
//    nodes are not allowed to have any edge leading to a ancestor nodes.
// The graph must be ascyclic.

//...............................................................
//
// Properties / Goals
//...............................................................
//
// path_ is a vector of strings that will be used
//
// searching the nodes, need to note the order in which a node becomes
// a dead end.
//
// set all the nodes as unvisited
//   if a node is visited, it cannot be a proper decendent
//
// determine if the graph is acyclic:  test for a cycle
//
//
// Try this:
// for each node
//    the node is a starting point if there are no incoming edges
//    for each remaining node
//       delete a node with no incoming edges
//       if cannot, fail
//       else, success

###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################


//  stack<Node> nodeStack;
  Reset(out_stream);
//  bool fullStack = false;
//
//  for(vector<Node>::iterator nodeIter = the_graph_.begin();
//                                     nodeIter != the_graph_.end(); ++nodeIter){
//    out_stream << (*nodeIter).GetNodeNumber() << "  " << (*nodeIter).GetIncomingCount() << endl;
//      nodeStack = Recurse((*nodeIter), nodeStack);
//    }
//
//
//  fullStack = (nodeStack.size() == the_graph_.size());
//  while(nodeStack.empty() == false){
//    if(fullStack)
//      out_stream << nodeStack.top().GetNodeNumber() << " ";
//    nodeStack.pop();
//  }


###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################



/******************************************************************************
 * Function 'Recurse'
 * This recursive function is initally called by DoTopoSort.
 * It will recurse while there are child nodes without incoming edges.
 *
 * Parameter:
 *   A single node.
**/
stack<Node> GraphCode::Recurse(Node n, stack<Node> nodeStack){

  vector<Node> children = GetChildren(n);
//  bool fullStack;

  if(n.HasNotBeenVisited()){
    nodeStack.push(n);
    n.SetVisited(true);
    for(vector<Node>::iterator childIter = children.begin();
                                    childIter != children.end(); ++childIter){
      (*childIter).DecrementIncoming();
      nodeStack=Recurse(n, nodeStack);
//      fullStack = (nodeStack.size() == the_graph_.size());
//      if(! fullStack){
//        (*childIter).IncrementIncoming();
//        (*childIter).SetVisited(false);
//      }
    }
  }

  return nodeStack;
}




###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################



/******************************************************************************
 * Function 'Reset'
 * Resets the visited
 *
 * Parameter:
 *   A vector of Nodes.
**/
void GraphCode::Reset(ofstream& out){

  stack<Node> nodeStack;
  vector<int> incomingVector;
  vector<int> childSubs;
  int max = 0;

  // make the incomingVector
  for(vector<Node>::iterator node = the_graph_.begin();
                                             node != the_graph_.end(); ++node){
    (*node).SetVisited(false);
    childSubs = (*node).GetChildSubs();

    for(vector<int>::iterator nodeNum = childSubs.begin();
                                         nodeNum != childSubs.end(); ++nodeNum)
      incomingVector.push_back(*nodeNum);
  }

  // increment incoming accordingly for each node, find max incoming
  for(vector<Node>::iterator node = the_graph_.begin();
                                             node != the_graph_.end(); ++node){
    for(vector<int>::iterator nodeNum = incomingVector.begin();
                                    nodeNum != incomingVector.end(); ++nodeNum)
      if( (*node).GetNodeNumber() == (*nodeNum))
        (*node).IncrementIncoming();
    max = ((*node).GetIncomingCount() > max) ? (*node).GetIncomingCount() : max;
  }

  // push the nodes on the stack in order of incoming edges
  for( int i = max; i > -1; --i)
    for(vector<Node>::reverse_iterator node = the_graph_.rbegin();
                                             node != the_graph_.rend(); ++node)
      if((*node).GetIncomingCount() == i) // mark this visited here
        nodeStack.push(*node);            // check its branches
  while( ! nodeStack.empty()){
    out << nodeStack.top().GetNodeNumber() << " ";
    nodeStack.pop();
  }

}
// the list is smallest number with least incoming
// to largest number with most incoming
// incoming is prioritized



###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################




/******************************************************************************
 * Function 'GetChildren'
 * This can get the child nodes of any node.
 *
 * Returns:
 *   A vector of child nodes
**/
vector<Node> GraphCode::GetChildren(Node n){

  vector<Node> children;
  vector<int> childSubs = n.GetChildSubs();

  for(vector<int>::iterator childNum = childSubs.begin();
                                       childNum != childSubs.end(); ++childNum)
    for(vector<Node>::iterator node = the_graph_.begin();
                                              node != the_graph_.end(); ++node)
      if(*childNum == (*node).GetNodeNumber())  children.push_back(*node);

  return children;

} // end GetChildren


###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################
###############################################################################







 stack<Node> Recurse(Node n, stack<Node> nodeStack);
 vector<Node> GetChildren(Node n);
 void Reset(ofstream& out);























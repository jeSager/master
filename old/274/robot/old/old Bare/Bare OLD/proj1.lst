   1               		.file	"proj1.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB0:
  15               		.file 1 "proj1.c"
   1:proj1.c       **** #include "timer.h"
   2:proj1.c       **** #include "cmod.h"
   3:proj1.c       **** #include "iroblib.h"
   4:proj1.c       **** #include "oi.h"
   5:proj1.c       **** #include <stdlib.h>
   6:proj1.c       **** 
   7:proj1.c       **** // Declare Global variables 
   8:proj1.c       ****    uint16_t DELAY; // 1ms delay
   9:proj1.c       ****    uint8_t notReadyBool; // play button detection
  10:proj1.c       **** 
  11:proj1.c       **** int main() {
  16               		.loc 1 11 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  12:proj1.c       ****   // Set up Create and module
  13:proj1.c       ****   initializeCommandModule();
  22               		.loc 1 13 0
  23 0000 0E94 0000 		call initializeCommandModule
  24               	.LVL0:
  14:proj1.c       ****     
  15:proj1.c       ****   powerOnRobot();
  25               		.loc 1 15 0
  26 0004 0E94 0000 		call powerOnRobot
  27               	.LVL1:
  16:proj1.c       ****     // Is the Robot on
  17:proj1.c       ****   byteTx(CmdStart);
  28               		.loc 1 17 0
  29 0008 80E8      		ldi r24,lo8(-128)
  30 000a 0E94 0000 		call byteTx
  31               	.LVL2:
  18:proj1.c       ****     // Start the create
  19:proj1.c       ****   baud(Baud57600);
  32               		.loc 1 19 0
  33 000e 8AE0      		ldi r24,lo8(10)
  34 0010 0E94 0000 		call baud
  35               	.LVL3:
  20:proj1.c       ****     // Set the baud rate for the Create and Command Module
  21:proj1.c       ****   defineSongs();
  36               		.loc 1 21 0
  37 0014 0E94 0000 		call defineSongs
  38               	.LVL4:
  22:proj1.c       ****     // Define some songs so that we know the robot is on.
  23:proj1.c       ****   byteTx(CmdControl);
  39               		.loc 1 23 0
  40 0018 82E8      		ldi r24,lo8(-126)
  41 001a 0E94 0000 		call byteTx
  42               	.LVL5:
  24:proj1.c       ****     // Deprecated form of safe mode. I use it because it will
  25:proj1.c       ****     // turn of all LEDs, so it's essentially a reset.
  26:proj1.c       ****   byteTx(CmdFull);
  43               		.loc 1 26 0
  44 001e 84E8      		ldi r24,lo8(-124)
  45 0020 0E94 0000 		call byteTx
  46               	.LVL6:
  27:proj1.c       ****     // We are operating in FULL mode.
  28:proj1.c       **** 
  29:proj1.c       ****   // CSCE 274 students: I would make sure the robot stops. 
  30:proj1.c       ****   //                    As a precaution for the robot and your grade.
  31:proj1.c       **** 
  32:proj1.c       ****   // Play the reset song and wait while it plays.
  33:proj1.c       ****    byteTx(CmdPlay);
  47               		.loc 1 33 0
  48 0024 8DE8      		ldi r24,lo8(-115)
  49 0026 0E94 0000 		call byteTx
  50               	.LVL7:
  34:proj1.c       ****    byteTx(RESET_SONG);
  51               		.loc 1 34 0
  52 002a 80E0      		ldi r24,0
  53 002c 0E94 0000 		call byteTx
  54               	.LVL8:
  35:proj1.c       ****    delayMs(750);
  55               		.loc 1 35 0
  56 0030 8EEE      		ldi r24,lo8(-18)
  57 0032 92E0      		ldi r25,lo8(2)
  58 0034 0E94 0000 		call delayMs
  59               	.LVL9:
  36:proj1.c       **** 
  37:proj1.c       ****   // Turn the power button on to something. I like red, but here is green.
  38:proj1.c       ****   // CSCE 274 students: The following should (will) be a function that you write.
  39:proj1.c       ****    byteTx(CmdLeds);
  60               		.loc 1 39 0
  61 0038 8BE8      		ldi r24,lo8(-117)
  62 003a 0E94 0000 		call byteTx
  63               	.LVL10:
  40:proj1.c       ****    byteTx(0x00);
  64               		.loc 1 40 0
  65 003e 80E0      		ldi r24,0
  66 0040 0E94 0000 		call byteTx
  67               	.LVL11:
  41:proj1.c       ****    byteTx(0);
  68               		.loc 1 41 0
  69 0044 80E0      		ldi r24,0
  70 0046 0E94 0000 		call byteTx
  71               	.LVL12:
  42:proj1.c       ****    byteTx(255);
  72               		.loc 1 42 0
  73 004a 8FEF      		ldi r24,lo8(-1)
  74 004c 0E94 0000 		call byteTx
  75               	.LVL13:
  43:proj1.c       ****   
  44:proj1.c       ****   // Methods
  45:proj1.c       ****    void setupLEDs(void) {
  46:proj1.c       ****    DDRD |= 0X60;
  47:proj1.c       ****    }
  48:proj1.c       ****    void rightLEDon(void) {
  49:proj1.c       ****    PORTD &= ~0x20;
  50:proj1.c       ****    }
  51:proj1.c       ****    void rightLEDoff(void) {
  52:proj1.c       ****    PORTD |= 0x20;
  53:proj1.c       ****    }
  54:proj1.c       ****    void leftLEDon(void) {
  55:proj1.c       ****    PORTD &= ~0x40;
  56:proj1.c       ****    }
  57:proj1.c       ****    void leftLEDoff(void) {
  58:proj1.c       ****    PORTD |= 0x40;
  59:proj1.c       ****    }
  60:proj1.c       **** 
  61:proj1.c       **** // Initialize global variables
  62:proj1.c       ****    DELAY=1000;
  76               		.loc 1 62 0
  77 0050 88EE      		ldi r24,lo8(-24)
  78 0052 93E0      		ldi r25,lo8(3)
  79 0054 9093 0000 		sts DELAY+1,r25
  80 0058 8093 0000 		sts DELAY,r24
  63:proj1.c       ****    notReadyBool=1; 
  81               		.loc 1 63 0
  82 005c 81E0      		ldi r24,lo8(1)
  83 005e 8093 0000 		sts notReadyBool,r24
  84               	.LVL14:
  85 0062 C5E0      		ldi r28,lo8(5)
  86               	.LVL15:
  87               	.L3:
  88               	.LBB30:
  89               	.LBB31:
  90               	.LBB32:
  46:proj1.c       ****    DDRD |= 0X60;
  91               		.loc 1 46 0
  92 0064 8AB1      		in r24,0xa
  93 0066 8066      		ori r24,lo8(96)
  94 0068 8AB9      		out 0xa,r24
  95               	.LBE32:
  96               	.LBE31:
  97               	.LBB33:
  98               	.LBB34:
  55:proj1.c       ****    PORTD &= ~0x40;
  99               		.loc 1 55 0
 100 006a 5E98      		cbi 0xb,6
 101               	.LBE34:
 102               	.LBE33:
  64:proj1.c       **** 
  65:proj1.c       **** // Task 1.1 (LED toggle)
  66:proj1.c       ****    for(uint8_t i=0;i<5;i++) {
  67:proj1.c       ****    setupLEDs();      // activate LEDs
  68:proj1.c       ****    leftLEDon();      // begin LED toggle
  69:proj1.c       ****    delayMs(DELAY);
 103               		.loc 1 69 0
 104 006c 8091 0000 		lds r24,DELAY
 105 0070 9091 0000 		lds r25,DELAY+1
 106 0074 0E94 0000 		call delayMs
 107               	.LVL16:
 108               	.LBB35:
 109               	.LBB36:
  58:proj1.c       ****    PORTD |= 0x40;
 110               		.loc 1 58 0
 111 0078 5E9A      		sbi 0xb,6
 112               	.LBE36:
 113               	.LBE35:
  70:proj1.c       ****    leftLEDoff();
  71:proj1.c       ****    delayMs(DELAY);
 114               		.loc 1 71 0
 115 007a 8091 0000 		lds r24,DELAY
 116 007e 9091 0000 		lds r25,DELAY+1
 117 0082 0E94 0000 		call delayMs
 118               	.LVL17:
 119               	.LBB37:
 120               	.LBB38:
  49:proj1.c       ****    PORTD &= ~0x20;
 121               		.loc 1 49 0
 122 0086 5D98      		cbi 0xb,5
 123               	.LBE38:
 124               	.LBE37:
  72:proj1.c       ****    rightLEDon();
  73:proj1.c       ****    delayMs(DELAY);
 125               		.loc 1 73 0
 126 0088 8091 0000 		lds r24,DELAY
 127 008c 9091 0000 		lds r25,DELAY+1
 128 0090 0E94 0000 		call delayMs
 129               	.LVL18:
 130               	.LBB39:
 131               	.LBB40:
  52:proj1.c       ****    PORTD |= 0x20;
 132               		.loc 1 52 0
 133 0094 5D9A      		sbi 0xb,5
 134               	.LBE40:
 135               	.LBE39:
  74:proj1.c       ****    rightLEDoff();
  75:proj1.c       ****    delayMs(DELAY);   // end LED toggle
 136               		.loc 1 75 0
 137 0096 8091 0000 		lds r24,DELAY
 138 009a 9091 0000 		lds r25,DELAY+1
 139 009e 0E94 0000 		call delayMs
 140               	.LVL19:
 141 00a2 C150      		subi r28,lo8(-(-1))
 142               	.LVL20:
  66:proj1.c       ****    for(uint8_t i=0;i<5;i++) {
 143               		.loc 1 66 0
 144 00a4 01F4      		brne .L3
 145               	.LVL21:
 146               	.L5:
 147               	.LBE30:
 148               	.LBB41:
 149               	.LBB42:
  76:proj1.c       ****    }
  77:proj1.c       **** 
  78:proj1.c       **** // Task 1.2, 1.3 (Bumper Sensors)
  79:proj1.c       ****    void bumpSense(void) {
  80:proj1.c       ****    uint8_t bumper;
  81:proj1.c       ****    while(UCSR0A & 0x80);   // clear the receive buffer
 150               		.loc 1 81 0
 151 00a6 8091 C000 		lds r24,192
 152 00aa 87FD      		sbrc r24,7
 153 00ac 00C0      		rjmp .L5
  82:proj1.c       ****    byteTx(142);            // sensor opcode
 154               		.loc 1 82 0
 155 00ae 8EE8      		ldi r24,lo8(-114)
 156 00b0 0E94 0000 		call byteTx
 157               	.LVL22:
  83:proj1.c       ****    byteTx(7);              // send request for packet 7
 158               		.loc 1 83 0
 159 00b4 87E0      		ldi r24,lo8(7)
 160 00b6 0E94 0000 		call byteTx
 161               	.LVL23:
  84:proj1.c       ****    bumper = byteRx();      // set bumper to received sensor packet
 162               		.loc 1 84 0
 163 00ba 0E94 0000 		call byteRx
 164               	.LVL24:
  85:proj1.c       ****       if(bumper==1) {         // check for right bumper detection
 165               		.loc 1 85 0
 166 00be 8130      		cpi r24,lo8(1)
 167 00c0 01F0      		breq .L17
  86:proj1.c       ****          rightLEDon();
  87:proj1.c       ****          }
  88:proj1.c       ****       else if(bumper==2) {    // check for left bumper detection
 168               		.loc 1 88 0
 169 00c2 8230      		cpi r24,lo8(2)
 170 00c4 01F4      		brne .L8
 171               	.LBB43:
 172               	.LBB44:
  55:proj1.c       ****    PORTD &= ~0x40;
 173               		.loc 1 55 0
 174 00c6 5E98      		cbi 0xb,6
 175 00c8 00C0      		rjmp .L11
 176               	.L8:
 177               	.LBE44:
 178               	.LBE43:
  89:proj1.c       ****          leftLEDon();
  90:proj1.c       ****          }
  91:proj1.c       ****       else if(bumper==3) {    // check for both bumpers
 179               		.loc 1 91 0
 180 00ca 8330      		cpi r24,lo8(3)
 181 00cc 01F4      		brne .L9
 182               	.LBB45:
 183               	.LBB46:
  55:proj1.c       ****    PORTD &= ~0x40;
 184               		.loc 1 55 0
 185 00ce 5E98      		cbi 0xb,6
 186               	.L17:
 187               	.LBE46:
 188               	.LBE45:
 189               	.LBB47:
 190               	.LBB48:
  49:proj1.c       ****    PORTD &= ~0x20;
 191               		.loc 1 49 0
 192 00d0 5D98      		cbi 0xb,5
 193 00d2 00C0      		rjmp .L11
 194               	.L9:
 195               	.LBE48:
 196               	.LBE47:
 197               	.LBB49:
 198               	.LBB50:
  58:proj1.c       ****    PORTD |= 0x40;
 199               		.loc 1 58 0
 200 00d4 5E9A      		sbi 0xb,6
 201               	.LBE50:
 202               	.LBE49:
 203               	.LBB51:
 204               	.LBB52:
  52:proj1.c       ****    PORTD |= 0x20;
 205               		.loc 1 52 0
 206 00d6 5D9A      		sbi 0xb,5
 207               	.LVL25:
 208               	.L11:
 209               	.LBE52:
 210               	.LBE51:
 211               	.LBE42:
 212               	.LBE41:
 213               	.LBB53:
 214               	.LBB54:
  92:proj1.c       ****          leftLEDon();
  93:proj1.c       ****          rightLEDon();
  94:proj1.c       ****          }
  95:proj1.c       ****       else {
  96:proj1.c       ****          leftLEDoff();
  97:proj1.c       ****          rightLEDoff();
  98:proj1.c       ****          }
  99:proj1.c       ****       }
 100:proj1.c       **** 
 101:proj1.c       **** // Task 2.1 (Drive)
 102:proj1.c       **** void tryPlay(void){
 103:proj1.c       **** 	uint8_t playPressed;
 104:proj1.c       **** 	while(UCSR0A & 0x80);   // clear the receive buffer
 215               		.loc 1 104 0
 216 00d8 8091 C000 		lds r24,192
 217 00dc 87FD      		sbrc r24,7
 218 00de 00C0      		rjmp .L11
 105:proj1.c       **** 	byteTx(142);            // sensor opcode
 219               		.loc 1 105 0
 220 00e0 8EE8      		ldi r24,lo8(-114)
 221 00e2 0E94 0000 		call byteTx
 222               	.LVL26:
 106:proj1.c       **** 	byteTx(18);              // send request for packet 18
 223               		.loc 1 106 0
 224 00e6 82E1      		ldi r24,lo8(18)
 225 00e8 0E94 0000 		call byteTx
 226               	.LVL27:
 107:proj1.c       **** 	playPressed = byteRx();      // set playPressed to received sensor packet
 227               		.loc 1 107 0
 228 00ec 0E94 0000 		call byteRx
 229               	.LVL28:
 108:proj1.c       **** 	if (playPressed==1){
 230               		.loc 1 108 0
 231 00f0 8130      		cpi r24,lo8(1)
 232 00f2 01F4      		brne .L12
 233 00f4 C4E0      		ldi r28,lo8(4)
 234 00f6 D0E0      		ldi r29,0
 235               	.LVL29:
 236               	.L14:
 237               	.LBB55:
 109:proj1.c       **** 		for(int i=0;i<4;i++){
 110:proj1.c       **** 			byteTx(158);
 238               		.loc 1 110 0
 239 00f8 8EE9      		ldi r24,lo8(-98)
 240 00fa 0E94 0000 		call byteTx
 241               	.LVL30:
 111:proj1.c       **** 			byteTx(17);
 242               		.loc 1 111 0
 243 00fe 81E1      		ldi r24,lo8(17)
 244 0100 0E94 0000 		call byteTx
 245               	.LVL31:
 112:proj1.c       **** 			notReadyBool=0;
 246               		.loc 1 112 0
 247 0104 1092 0000 		sts notReadyBool,__zero_reg__
 113:proj1.c       **** 			//drive straight
 114:proj1.c       **** 			byteTx(CmdDrive);
 248               		.loc 1 114 0
 249 0108 89E8      		ldi r24,lo8(-119)
 250 010a 0E94 0000 		call byteTx
 251               	.LVL32:
 115:proj1.c       **** 			byteTx(0x01);//velocity 300mm/s
 252               		.loc 1 115 0
 253 010e 81E0      		ldi r24,lo8(1)
 254 0110 0E94 0000 		call byteTx
 255               	.LVL33:
 116:proj1.c       **** 			byteTx(0x2c);
 256               		.loc 1 116 0
 257 0114 8CE2      		ldi r24,lo8(44)
 258 0116 0E94 0000 		call byteTx
 259               	.LVL34:
 117:proj1.c       **** 			byteTx(0x7f);//radius
 260               		.loc 1 117 0
 261 011a 8FE7      		ldi r24,lo8(127)
 262 011c 0E94 0000 		call byteTx
 263               	.LVL35:
 118:proj1.c       **** 			byteTx(0xff);
 264               		.loc 1 118 0
 265 0120 8FEF      		ldi r24,lo8(-1)
 266 0122 0E94 0000 		call byteTx
 267               	.LVL36:
 119:proj1.c       **** 
 120:proj1.c       **** 			delayMs(2800);
 268               		.loc 1 120 0
 269 0126 80EF      		ldi r24,lo8(-16)
 270 0128 9AE0      		ldi r25,lo8(10)
 271 012a 0E94 0000 		call delayMs
 272               	.LVL37:
 121:proj1.c       **** 
 122:proj1.c       **** 			//turn in place
 123:proj1.c       **** 			byteTx(CmdDrive);
 273               		.loc 1 123 0
 274 012e 89E8      		ldi r24,lo8(-119)
 275 0130 0E94 0000 		call byteTx
 276               	.LVL38:
 124:proj1.c       **** 			byteTx(0x01);//velocity 300mm/s
 277               		.loc 1 124 0
 278 0134 81E0      		ldi r24,lo8(1)
 279 0136 0E94 0000 		call byteTx
 280               	.LVL39:
 125:proj1.c       **** 			byteTx(0x2c);
 281               		.loc 1 125 0
 282 013a 8CE2      		ldi r24,lo8(44)
 283 013c 0E94 0000 		call byteTx
 284               	.LVL40:
 126:proj1.c       **** 			byteTx(0xff);//radius
 285               		.loc 1 126 0
 286 0140 8FEF      		ldi r24,lo8(-1)
 287 0142 0E94 0000 		call byteTx
 288               	.LVL41:
 127:proj1.c       **** 			byteTx(0xff);
 289               		.loc 1 127 0
 290 0146 8FEF      		ldi r24,lo8(-1)
 291 0148 0E94 0000 		call byteTx
 292               	.LVL42:
 128:proj1.c       **** 
 129:proj1.c       **** 			delayMs(600);
 293               		.loc 1 129 0
 294 014c 88E5      		ldi r24,lo8(88)
 295 014e 92E0      		ldi r25,lo8(2)
 296 0150 0E94 0000 		call delayMs
 297               	.LVL43:
 298 0154 2197      		sbiw r28,1
 299               	.LVL44:
 109:proj1.c       **** 		for(int i=0;i<4;i++){
 300               		.loc 1 109 0
 301 0156 2097      		sbiw r28,0
 302 0158 01F4      		brne .L14
 303               	.LBE55:
 130:proj1.c       **** 		}
 131:proj1.c       **** 	powerOffRobot();
 304               		.loc 1 131 0
 305 015a 0E94 0000 		call powerOffRobot
 306               	.LVL45:
 307               	.L12:
 308               	.LBE54:
 309               	.LBE53:
 132:proj1.c       **** 	}
 133:proj1.c       **** 	//else do nothing
 134:proj1.c       **** 	
 135:proj1.c       **** }
 136:proj1.c       **** 
 137:proj1.c       ****   // Infinite operation loop
 138:proj1.c       ****    for(;;) {
 139:proj1.c       ****       bumpSense();
 140:proj1.c       ****       tryPlay();
 141:proj1.c       ****       delayMs(10);
 310               		.loc 1 141 0
 311 015e 8AE0      		ldi r24,lo8(10)
 312 0160 90E0      		ldi r25,0
 313 0162 0E94 0000 		call delayMs
 314               	.LVL46:
 142:proj1.c       ****       if(UserButtonPressed) {
 315               		.loc 1 142 0
 316 0166 4C99      		sbic 0x9,4
 317 0168 00C0      		rjmp .L5
 143:proj1.c       ****         powerOffRobot();
 318               		.loc 1 143 0
 319 016a 0E94 0000 		call powerOffRobot
 320               	.LVL47:
 144:proj1.c       ****         exit(1);
 321               		.loc 1 144 0
 322 016e 81E0      		ldi r24,lo8(1)
 323 0170 90E0      		ldi r25,0
 324 0172 0E94 0000 		call exit
 325               	.LVL48:
 326               		.cfi_endproc
 327               	.LFE0:
 329               		.comm	notReadyBool,1,1
 330               		.comm	DELAY,2,1
 331               		.text
 332               	.Letext0:
 333               		.file 2 "/usr/lib/avr/include/stdint.h"
 334               		.file 3 "timer.h"
 335               		.file 4 "cmod.h"
 336               		.file 5 "iroblib.h"
 337               		.file 6 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 proj1.c
     /tmp/ccPO7x2O.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPO7x2O.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPO7x2O.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPO7x2O.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPO7x2O.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPO7x2O.s:13     .text.startup:0000000000000000 main
                            *COM*:0000000000000002 DELAY
                            *COM*:0000000000000001 notReadyBool

UNDEFINED SYMBOLS
initializeCommandModule
powerOnRobot
byteTx
baud
defineSongs
delayMs
byteRx
powerOffRobot
exit
__do_clear_bss

   1               		.file	"proj1.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	stop
  12               	stop:
  13               	.LFB8:
  14               		.file 1 "proj1.c"
   1:proj1.c       **** #include "timer.h"
   2:proj1.c       **** #include "cmod.h"
   3:proj1.c       **** #include "iroblib.h"
   4:proj1.c       **** #include "oi.h"
   5:proj1.c       **** #include <stdlib.h>
   6:proj1.c       **** #include <stdio.h>
   7:proj1.c       **** #include <string.h>
   8:proj1.c       **** 
   9:proj1.c       **** // Declare Global variables 
  10:proj1.c       **** uint16_t DELAY; // 1ms delay
  11:proj1.c       **** uint8_t notReadyBool; // play button detection
  12:proj1.c       **** double PI=3.14159265358979323846;
  13:proj1.c       **** int true=1;
  14:proj1.c       **** int false=0;
  15:proj1.c       **** uint8_t sensors[Sen6Size];
  16:proj1.c       **** uint8_t safe=0;
  17:proj1.c       **** uint8_t unsafeRotate=0;
  18:proj1.c       **** uint8_t isRotating=0;
  19:proj1.c       **** 
  20:proj1.c       **** // functions
  21:proj1.c       **** int main(void);
  22:proj1.c       **** void printBuffer(char buf[]);
  23:proj1.c       **** void rotateDegreeRight(int right);
  24:proj1.c       **** void driveStraightDistance(void);
  25:proj1.c       **** //void turnDelay(int rotateDelayMS, int right);
  26:proj1.c       **** //void checkSensor(void);
  27:proj1.c       **** void stop(void);
  28:proj1.c       **** 
  29:proj1.c       **** int main(void) {
  30:proj1.c       **** 	// Set up Create and module
  31:proj1.c       **** 	initializeCommandModule();
  32:proj1.c       **** 
  33:proj1.c       **** 	powerOnRobot();
  34:proj1.c       **** 	// Is the Robot on
  35:proj1.c       **** 	byteTx(CmdStart);
  36:proj1.c       **** 	// Start the create
  37:proj1.c       **** 	baud(Baud57600);
  38:proj1.c       **** 	// Set the baud rate for the Create and Command Module
  39:proj1.c       **** 	defineSongs();
  40:proj1.c       **** 	// Define some songs so that we know the robot is on.
  41:proj1.c       **** 	byteTx(CmdControl);
  42:proj1.c       **** 	// Deprecated form of safe mode. I use it because it will
  43:proj1.c       **** 	// turn of all LEDs, so it's essentially a reset.
  44:proj1.c       **** 	byteTx(CmdFull);
  45:proj1.c       **** 	// We are operating in FULL mode.
  46:proj1.c       **** 
  47:proj1.c       **** 	// CSCE 274 students: I would make sure the robot stops. 
  48:proj1.c       **** 	//                    As a precaution for the robot and your grade.
  49:proj1.c       **** 
  50:proj1.c       **** 	// Play the reset song and wait while it plays.
  51:proj1.c       **** 	byteTx(CmdPlay);
  52:proj1.c       **** 	byteTx(RESET_SONG);
  53:proj1.c       **** 	delayMs(750);
  54:proj1.c       **** 
  55:proj1.c       **** 	// Turn the power button on to something. I like red, but here is green.
  56:proj1.c       **** 	// CSCE 274 students: The following should (will) be a function that you write.
  57:proj1.c       **** 	byteTx(CmdLeds);
  58:proj1.c       **** 	byteTx(0x00);
  59:proj1.c       **** 	byteTx(0);
  60:proj1.c       **** 	byteTx(255);
  61:proj1.c       **** 
  62:proj1.c       **** 	// Methods
  63:proj1.c       **** 	void setupLEDs(void) {
  64:proj1.c       **** 		DDRD |= 0X60;
  65:proj1.c       **** 	}
  66:proj1.c       **** 	void rightLEDon(void) {
  67:proj1.c       **** 		PORTD &= ~0x20;
  68:proj1.c       **** 	}
  69:proj1.c       **** 	void rightLEDoff(void) {
  70:proj1.c       **** 		PORTD |= 0x20;
  71:proj1.c       **** 	}
  72:proj1.c       **** 	void leftLEDon(void) {
  73:proj1.c       **** 		PORTD &= ~0x40;
  74:proj1.c       **** 	}
  75:proj1.c       **** 	void leftLEDoff(void) {
  76:proj1.c       **** 		PORTD |= 0x40;
  77:proj1.c       **** 	}
  78:proj1.c       **** 
  79:proj1.c       **** 	// Initialize global variables
  80:proj1.c       **** 	DELAY=1000;
  81:proj1.c       **** 	notReadyBool=1;
  82:proj1.c       **** 
  83:proj1.c       **** 	// Task 1.2, 1.3 (Bumper Sensors)
  84:proj1.c       **** 	void bumpSense(void) {
  85:proj1.c       **** 		uint8_t bumper;
  86:proj1.c       **** 		while(UCSR0A & 0x80);   // clear the receive buffer
  87:proj1.c       **** 		byteTx(142);            // sensor opcode
  88:proj1.c       **** 		byteTx(7);              // send request for packet 7
  89:proj1.c       **** 		bumper = byteRx();      // set bumper to received sensor packet
  90:proj1.c       **** 		if(bumper==1) {         // check for right bumper detection
  91:proj1.c       **** 			rightLEDon();
  92:proj1.c       **** 		}
  93:proj1.c       **** 		else if(bumper==2) {    // check for left bumper detection
  94:proj1.c       **** 			leftLEDon();
  95:proj1.c       **** 		}
  96:proj1.c       **** 		else if(bumper==3) {    // check for both bumpers
  97:proj1.c       **** 			leftLEDon();
  98:proj1.c       **** 			rightLEDon();
  99:proj1.c       **** 		}
 100:proj1.c       **** 		else {
 101:proj1.c       **** 			leftLEDoff();
 102:proj1.c       **** 			rightLEDoff();
 103:proj1.c       **** 		}
 104:proj1.c       **** 	}
 105:proj1.c       **** 
 106:proj1.c       **** 	// Infinite operation loop
 107:proj1.c       **** 	for(;;) {
 108:proj1.c       **** 		setupLEDs();
 109:proj1.c       **** 		if(canSense==1){
 110:proj1.c       **** 			//cli();
 111:proj1.c       **** 			uint8_t i=0;
 112:proj1.c       **** 			while(UCSR0A & 0x80)
 113:proj1.c       **** 			i = UDR0;
 114:proj1.c       **** 			byteTx(CmdSensors);  // sensor opcode 
 115:proj1.c       **** 			byteTx(6);   // send request for packet 0 
 116:proj1.c       **** 			for(uint8_t i = 0; i < Sen6Size; i++) { // read each sensor byte
 117:proj1.c       **** 			   sensors[i] = byteRx();
 118:proj1.c       **** 			}
 119:proj1.c       **** 			if(sensors[SenCliffR]==1 || sensors[SenCliffFR]==1 || sensors[SenCliffL]==1 || sensors[SenCliffF
 120:proj1.c       **** 		   		safe=1; // unsafe to drive
 121:proj1.c       **** 			}
 122:proj1.c       **** 			else if(sensors[SenBumpDrop]==1 || sensors[SenBumpDrop]==2 || sensors[SenBumpDrop]==3) {
 123:proj1.c       **** 		   		safe=1; // unsafe to drive
 124:proj1.c       **** 			}
 125:proj1.c       **** 			else safe=0; // safe case
 126:proj1.c       **** 			if(sensors[SenBumpDrop]==4 || sensors[SenBumpDrop]==8 || sensors[SenBumpDrop]==16 || sensors[Sen
 127:proj1.c       **** 				unsafeRotate=1; // wheel drop, cannot rotate
 128:proj1.c       **** 			}
 129:proj1.c       **** 			else unsafeRotate=0;
 130:proj1.c       **** 			//sei();
 131:proj1.c       **** 			senseTimerCount=100;
 132:proj1.c       **** 			canSense=0;
 133:proj1.c       **** 		}
 134:proj1.c       **** 
 135:proj1.c       **** 		
 136:proj1.c       **** 		if(isRotating==1 && unsafeRotate==1){//do jackShit
 137:proj1.c       **** 		}
 138:proj1.c       **** 
 139:proj1.c       **** 		else if(sensors[SenIRChar]==130&&safe==0) { // forward
 140:proj1.c       **** 		driveStraightDistance();
 141:proj1.c       **** 		}
 142:proj1.c       **** 
 143:proj1.c       **** 		else if(sensors[SenIRChar]==131&&unsafeRotate==0) { // rotate right
 144:proj1.c       **** 		rotateDegreeRight(1);
 145:proj1.c       **** 		}
 146:proj1.c       **** 
 147:proj1.c       **** 		else if(sensors[SenIRChar]==129&&unsafeRotate==0) { // rotate left
 148:proj1.c       **** 		rotateDegreeRight(0);
 149:proj1.c       **** 		}
 150:proj1.c       **** 
 151:proj1.c       **** 		else stop();
 152:proj1.c       **** 
 153:proj1.c       **** 		delayMs(15);
 154:proj1.c       **** 		if(UserButtonPressed) {
 155:proj1.c       **** 			powerOffRobot();
 156:proj1.c       **** 			exit(1);
 157:proj1.c       **** 		}
 158:proj1.c       **** 	}
 159:proj1.c       **** }
 160:proj1.c       **** 
 161:proj1.c       **** void stop(void) {
  15               		.loc 1 161 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 162:proj1.c       **** byteTx(CmdDriveWheels);
  21               		.loc 1 162 0
  22 0000 81E9      		ldi r24,lo8(-111)
  23 0002 0E94 0000 		call byteTx
  24               	.LVL0:
 163:proj1.c       **** byteTx(0x00);//velocity right wheel 300mm/s
  25               		.loc 1 163 0
  26 0006 80E0      		ldi r24,0
  27 0008 0E94 0000 		call byteTx
  28               	.LVL1:
 164:proj1.c       **** byteTx(0x00);
  29               		.loc 1 164 0
  30 000c 80E0      		ldi r24,0
  31 000e 0E94 0000 		call byteTx
  32               	.LVL2:
 165:proj1.c       **** byteTx(0x00);//velocity left wheel 300mm/s
  33               		.loc 1 165 0
  34 0012 80E0      		ldi r24,0
  35 0014 0E94 0000 		call byteTx
  36               	.LVL3:
 166:proj1.c       **** byteTx(0x00);
  37               		.loc 1 166 0
  38 0018 80E0      		ldi r24,0
  39 001a 0C94 0000 		jmp byteTx
  40               	.LVL4:
  41               		.cfi_endproc
  42               	.LFE8:
  44               	.global	printBuffer
  46               	printBuffer:
  47               	.LFB9:
 167:proj1.c       **** }
 168:proj1.c       **** 
 169:proj1.c       **** void printBuffer(char buf[]) {
  48               		.loc 1 169 0
  49               		.cfi_startproc
  50               	.LVL5:
  51 001e 0F93      		push r16
  52               	.LCFI0:
  53               		.cfi_def_cfa_offset 3
  54               		.cfi_offset 16, -2
  55 0020 1F93      		push r17
  56               	.LCFI1:
  57               		.cfi_def_cfa_offset 4
  58               		.cfi_offset 17, -3
  59 0022 CF93      		push r28
  60               	.LCFI2:
  61               		.cfi_def_cfa_offset 5
  62               		.cfi_offset 28, -4
  63 0024 DF93      		push r29
  64               	.LCFI3:
  65               		.cfi_def_cfa_offset 6
  66               		.cfi_offset 29, -5
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 4 */
  70               	.L__stack_usage = 4
  71 0026 EC01      		movw r28,r24
  72               	.LVL6:
 170:proj1.c       **** 	int i;
 171:proj1.c       **** 	for(i = 0; i < strlen(buf); i++) {
  73               		.loc 1 171 0
  74 0028 8C01      		movw r16,r24
  75               	.LVL7:
  76               	.L3:
  77               		.loc 1 171 0 is_stmt 0 discriminator 1
  78 002a FE01      		movw r30,r28
  79               		0:
  80 002c 0190      		ld __tmp_reg__,Z+
  81 002e 0020      		tst __tmp_reg__
  82 0030 01F4      		brne 0b
  83 0032 3197      		sbiw r30,1
  84 0034 EC1B      		sub r30,r28
  85 0036 FD0B      		sbc r31,r29
  86 0038 C801      		movw r24,r16
  87 003a 8C1B      		sub r24,r28
  88 003c 9D0B      		sbc r25,r29
  89               	.LVL8:
  90 003e 8E17      		cp r24,r30
  91 0040 9F07      		cpc r25,r31
  92 0042 00F4      		brsh .L6
 172:proj1.c       **** 		byteTx(buf[i]);
  93               		.loc 1 172 0 is_stmt 1 discriminator 2
  94 0044 F801      		movw r30,r16
  95 0046 8191      		ld r24,Z+
  96               	.LVL9:
  97 0048 8F01      		movw r16,r30
  98               	.LVL10:
  99 004a 0E94 0000 		call byteTx
 100               	.LVL11:
 101 004e 00C0      		rjmp .L3
 102               	.LVL12:
 103               	.L6:
 104               	/* epilogue start */
 173:proj1.c       **** 	    }
 174:proj1.c       **** 	}
 105               		.loc 1 174 0
 106 0050 DF91      		pop r29
 107 0052 CF91      		pop r28
 108               	.LVL13:
 109 0054 1F91      		pop r17
 110 0056 0F91      		pop r16
 111 0058 0895      		ret
 112               		.cfi_endproc
 113               	.LFE9:
 115               	.global	rotateDegreeRight
 117               	rotateDegreeRight:
 118               	.LFB10:
 175:proj1.c       **** /*
 176:proj1.c       **** 	void checkSensor(void) {
 177:proj1.c       **** 		if(sensors[SenCliffR]==1 || sensors[SenCliffFR]==1 || sensors[SenBumpDrop]==1) {
 178:proj1.c       **** 		   safe=1; // unsafe on right
 179:proj1.c       **** 		}
 180:proj1.c       **** 		else if(sensors[SenCliffL]==1 || sensors[SenCliffFL]==1 || sensors[SenBumpDrop]==2) {
 181:proj1.c       **** 		   safe=2; // unsafe on left
 182:proj1.c       **** 		}
 183:proj1.c       **** 		else safe=0; // 0=safe case
 184:proj1.c       **** 	}
 185:proj1.c       **** 
 186:proj1.c       **** 	void turnDelay(int rotateDelayMS, int right){
 187:proj1.c       **** 		//to check sensors while turning
 188:proj1.c       **** 		while(safe==0 && rotateDelayMS!=0){
 189:proj1.c       **** 			checkSensor();
 190:proj1.c       **** 			delayMs(1);
 191:proj1.c       **** 			rotateDelayMS=rotateDelayMS--;
 192:proj1.c       **** 		}
 193:proj1.c       **** 		//if sensor bumped while turning
 194:proj1.c       **** 		if(safe==1&&right==1){
 195:proj1.c       **** 			rotateDegreeRight(0);
 196:proj1.c       **** 		}
 197:proj1.c       **** 		else if(safe==2&&right==0){
 198:proj1.c       **** 			rotateDegreeRight(1);		
 199:proj1.c       **** 		}
 200:proj1.c       **** 		if(safe==0){
 201:proj1.c       **** 			driveStraightDistance();		
 202:proj1.c       **** 		}
 203:proj1.c       **** 	}
 204:proj1.c       **** */
 205:proj1.c       **** 	void rotateDegreeRight(int right){
 119               		.loc 1 205 0
 120               		.cfi_startproc
 121               	.LVL14:
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
 206:proj1.c       **** 		int rotateDelayMs = 30*16;//gives proper degree at 30cm/s
 207:proj1.c       **** 		safe=0;
 126               		.loc 1 207 0
 127 005a 1092 0000 		sts safe,__zero_reg__
 208:proj1.c       **** 		isRotating=1;
 128               		.loc 1 208 0
 129 005e 21E0      		ldi r18,lo8(1)
 130 0060 2093 0000 		sts isRotating,r18
 209:proj1.c       **** 		if(right==1){//if turning right
 131               		.loc 1 209 0
 132 0064 0197      		sbiw r24,1
 133 0066 01F4      		brne .L8
 210:proj1.c       **** 			byteTx(CmdDriveWheels);
 134               		.loc 1 210 0
 135 0068 81E9      		ldi r24,lo8(-111)
 136               	.LVL15:
 137 006a 0E94 0000 		call byteTx
 138               	.LVL16:
 211:proj1.c       **** 			byteTx(0xfe);//velocity right wheel -300mm/s
 139               		.loc 1 211 0
 140 006e 8EEF      		ldi r24,lo8(-2)
 141 0070 0E94 0000 		call byteTx
 142               	.LVL17:
 212:proj1.c       **** 			byteTx(0xd4);
 143               		.loc 1 212 0
 144 0074 84ED      		ldi r24,lo8(-44)
 145 0076 0E94 0000 		call byteTx
 146               	.LVL18:
 213:proj1.c       **** 			byteTx(0x01);//velocity left wheel 300mm/s
 147               		.loc 1 213 0
 148 007a 81E0      		ldi r24,lo8(1)
 149 007c 0E94 0000 		call byteTx
 150               	.LVL19:
 214:proj1.c       **** 			byteTx(0x2c);
 151               		.loc 1 214 0
 152 0080 8CE2      		ldi r24,lo8(44)
 153 0082 00C0      		rjmp .L10
 154               	.LVL20:
 155               	.L8:
 215:proj1.c       **** 			//checkSensor();
 216:proj1.c       **** 		}
 217:proj1.c       **** 		else{//if turning left
 218:proj1.c       **** 			byteTx(CmdDriveWheels);
 156               		.loc 1 218 0
 157 0084 81E9      		ldi r24,lo8(-111)
 158               	.LVL21:
 159 0086 0E94 0000 		call byteTx
 160               	.LVL22:
 219:proj1.c       **** 			byteTx(0x01);//velocity right wheel 300mm/s  
 161               		.loc 1 219 0
 162 008a 81E0      		ldi r24,lo8(1)
 163 008c 0E94 0000 		call byteTx
 164               	.LVL23:
 220:proj1.c       **** 			byteTx(0x2c);
 165               		.loc 1 220 0
 166 0090 8CE2      		ldi r24,lo8(44)
 167 0092 0E94 0000 		call byteTx
 168               	.LVL24:
 221:proj1.c       **** 			byteTx(0xfe);//velocity left wheel -300mm/s
 169               		.loc 1 221 0
 170 0096 8EEF      		ldi r24,lo8(-2)
 171 0098 0E94 0000 		call byteTx
 172               	.LVL25:
 222:proj1.c       **** 			byteTx(0xd4);
 173               		.loc 1 222 0
 174 009c 84ED      		ldi r24,lo8(-44)
 175               	.L10:
 176 009e 0E94 0000 		call byteTx
 177               	.LVL26:
 223:proj1.c       **** 			//checkSensor();
 224:proj1.c       **** 		}
 225:proj1.c       **** 		delayMs(rotateDelayMs);
 178               		.loc 1 225 0
 179 00a2 80EE      		ldi r24,lo8(-32)
 180 00a4 91E0      		ldi r25,lo8(1)
 181 00a6 0C94 0000 		jmp delayMs
 182               	.LVL27:
 183               		.cfi_endproc
 184               	.LFE10:
 186               	.global	driveStraightDistance
 188               	driveStraightDistance:
 189               	.LFB11:
 226:proj1.c       **** 		isRotating==0;
 227:proj1.c       **** 	}
 228:proj1.c       **** 
 229:proj1.c       **** 	void driveStraightDistance(void){
 190               		.loc 1 229 0
 191               		.cfi_startproc
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
 230:proj1.c       **** 			byteTx(CmdDriveWheels);
 196               		.loc 1 230 0
 197 00aa 81E9      		ldi r24,lo8(-111)
 198 00ac 0E94 0000 		call byteTx
 199               	.LVL28:
 231:proj1.c       **** 			byteTx(0x01);//velocity right wheel 300mm/s
 200               		.loc 1 231 0
 201 00b0 81E0      		ldi r24,lo8(1)
 202 00b2 0E94 0000 		call byteTx
 203               	.LVL29:
 232:proj1.c       **** 			byteTx(0x2c);
 204               		.loc 1 232 0
 205 00b6 8CE2      		ldi r24,lo8(44)
 206 00b8 0E94 0000 		call byteTx
 207               	.LVL30:
 233:proj1.c       **** 			byteTx(0x01);//velocity left wheel 300mm/s
 208               		.loc 1 233 0
 209 00bc 81E0      		ldi r24,lo8(1)
 210 00be 0E94 0000 		call byteTx
 211               	.LVL31:
 234:proj1.c       **** 			byteTx(0x2c);
 212               		.loc 1 234 0
 213 00c2 8CE2      		ldi r24,lo8(44)
 214 00c4 0C94 0000 		jmp byteTx
 215               	.LVL32:
 216               		.cfi_endproc
 217               	.LFE11:
 219               		.section	.text.startup,"ax",@progbits
 220               	.global	main
 222               	main:
 223               	.LFB1:
  29:proj1.c       **** int main(void) {
 224               		.loc 1 29 0
 225               		.cfi_startproc
 226               	/* prologue: function */
 227               	/* frame size = 0 */
 228               	/* stack size = 0 */
 229               	.L__stack_usage = 0
  31:proj1.c       **** 	initializeCommandModule();
 230               		.loc 1 31 0
 231 0000 0E94 0000 		call initializeCommandModule
 232               	.LVL33:
  33:proj1.c       **** 	powerOnRobot();
 233               		.loc 1 33 0
 234 0004 0E94 0000 		call powerOnRobot
 235               	.LVL34:
  35:proj1.c       **** 	byteTx(CmdStart);
 236               		.loc 1 35 0
 237 0008 80E8      		ldi r24,lo8(-128)
 238 000a 0E94 0000 		call byteTx
 239               	.LVL35:
  37:proj1.c       **** 	baud(Baud57600);
 240               		.loc 1 37 0
 241 000e 8AE0      		ldi r24,lo8(10)
 242 0010 0E94 0000 		call baud
 243               	.LVL36:
  39:proj1.c       **** 	defineSongs();
 244               		.loc 1 39 0
 245 0014 0E94 0000 		call defineSongs
 246               	.LVL37:
  41:proj1.c       **** 	byteTx(CmdControl);
 247               		.loc 1 41 0
 248 0018 82E8      		ldi r24,lo8(-126)
 249 001a 0E94 0000 		call byteTx
 250               	.LVL38:
  44:proj1.c       **** 	byteTx(CmdFull);
 251               		.loc 1 44 0
 252 001e 84E8      		ldi r24,lo8(-124)
 253 0020 0E94 0000 		call byteTx
 254               	.LVL39:
  51:proj1.c       **** 	byteTx(CmdPlay);
 255               		.loc 1 51 0
 256 0024 8DE8      		ldi r24,lo8(-115)
 257 0026 0E94 0000 		call byteTx
 258               	.LVL40:
  52:proj1.c       **** 	byteTx(RESET_SONG);
 259               		.loc 1 52 0
 260 002a 80E0      		ldi r24,0
 261 002c 0E94 0000 		call byteTx
 262               	.LVL41:
  53:proj1.c       **** 	delayMs(750);
 263               		.loc 1 53 0
 264 0030 8EEE      		ldi r24,lo8(-18)
 265 0032 92E0      		ldi r25,lo8(2)
 266 0034 0E94 0000 		call delayMs
 267               	.LVL42:
  57:proj1.c       **** 	byteTx(CmdLeds);
 268               		.loc 1 57 0
 269 0038 8BE8      		ldi r24,lo8(-117)
 270 003a 0E94 0000 		call byteTx
 271               	.LVL43:
  58:proj1.c       **** 	byteTx(0x00);
 272               		.loc 1 58 0
 273 003e 80E0      		ldi r24,0
 274 0040 0E94 0000 		call byteTx
 275               	.LVL44:
  59:proj1.c       **** 	byteTx(0);
 276               		.loc 1 59 0
 277 0044 80E0      		ldi r24,0
 278 0046 0E94 0000 		call byteTx
 279               	.LVL45:
  60:proj1.c       **** 	byteTx(255);
 280               		.loc 1 60 0
 281 004a 8FEF      		ldi r24,lo8(-1)
 282 004c 0E94 0000 		call byteTx
 283               	.LVL46:
  80:proj1.c       **** 	DELAY=1000;
 284               		.loc 1 80 0
 285 0050 88EE      		ldi r24,lo8(-24)
 286 0052 93E0      		ldi r25,lo8(3)
 287 0054 9093 0000 		sts DELAY+1,r25
 288 0058 8093 0000 		sts DELAY,r24
  81:proj1.c       **** 	notReadyBool=1;
 289               		.loc 1 81 0
 290 005c 81E0      		ldi r24,lo8(1)
 291 005e 8093 0000 		sts notReadyBool,r24
 292               	.LBB6:
 131:proj1.c       **** 			senseTimerCount=100;
 293               		.loc 1 131 0
 294 0062 04E6      		ldi r16,lo8(100)
 295 0064 10E0      		ldi r17,0
 127:proj1.c       **** 				unsafeRotate=1; // wheel drop, cannot rotate
 296               		.loc 1 127 0
 297 0066 FF24      		clr r15
 298 0068 F394      		inc r15
 299               	.L30:
 300               	.LBE6:
 301               	.LBB8:
 302               	.LBB9:
  64:proj1.c       **** 		DDRD |= 0X60;
 303               		.loc 1 64 0
 304 006a 8AB1      		in r24,0xa
 305 006c 8066      		ori r24,lo8(96)
 306 006e 8AB9      		out 0xa,r24
 307               	.LBE9:
 308               	.LBE8:
 109:proj1.c       **** 		if(canSense==1){
 309               		.loc 1 109 0
 310 0070 8091 0000 		lds r24,canSense
 311 0074 8130      		cpi r24,lo8(1)
 312 0076 01F0      		breq .+2
 313 0078 00C0      		rjmp .L13
 314               	.L14:
 315               	.LBB10:
 112:proj1.c       **** 			while(UCSR0A & 0x80)
 316               		.loc 1 112 0 discriminator 1
 317 007a 8091 C000 		lds r24,192
 318 007e 87FF      		sbrs r24,7
 319 0080 00C0      		rjmp .L53
 113:proj1.c       **** 			i = UDR0;
 320               		.loc 1 113 0
 321 0082 8091 C600 		lds r24,198
 322 0086 00C0      		rjmp .L14
 323               	.L53:
 114:proj1.c       **** 			byteTx(CmdSensors);  // sensor opcode 
 324               		.loc 1 114 0
 325 0088 8EE8      		ldi r24,lo8(-114)
 326 008a 0E94 0000 		call byteTx
 327               	.LVL47:
 115:proj1.c       **** 			byteTx(6);   // send request for packet 0 
 328               		.loc 1 115 0
 329 008e 86E0      		ldi r24,lo8(6)
 330 0090 0E94 0000 		call byteTx
 331               	.LVL48:
 332 0094 C0E0      		ldi r28,lo8(sensors)
 333 0096 D0E0      		ldi r29,hi8(sensors)
 334               	.LVL49:
 335               	.L17:
 336               	.LBB7:
 117:proj1.c       **** 			   sensors[i] = byteRx();
 337               		.loc 1 117 0 discriminator 2
 338 0098 0E94 0000 		call byteRx
 339               	.LVL50:
 340 009c 8993      		st Y+,r24
 341               	.LVL51:
 116:proj1.c       **** 			for(uint8_t i = 0; i < Sen6Size; i++) { // read each sensor byte
 342               		.loc 1 116 0 discriminator 2
 343 009e 80E0      		ldi r24,hi8(sensors+52)
 344 00a0 C030      		cpi r28,lo8(sensors+52)
 345 00a2 D807      		cpc r29,r24
 346 00a4 01F4      		brne .L17
 347               	.LBE7:
 119:proj1.c       **** 			if(sensors[SenCliffR]==1 || sensors[SenCliffFR]==1 || sensors[SenCliffL]==1 || sensors[SenCliffF
 348               		.loc 1 119 0
 349 00a6 9091 0000 		lds r25,sensors+5
 350 00aa 8091 0000 		lds r24,sensors
 351 00ae 9130      		cpi r25,lo8(1)
 352 00b0 01F0      		breq .L18
 119:proj1.c       **** 			if(sensors[SenCliffR]==1 || sensors[SenCliffFR]==1 || sensors[SenCliffL]==1 || sensors[SenCliffF
 353               		.loc 1 119 0 is_stmt 0 discriminator 1
 354 00b2 9091 0000 		lds r25,sensors+4
 355 00b6 9130      		cpi r25,lo8(1)
 356 00b8 01F0      		breq .L18
 357 00ba 9091 0000 		lds r25,sensors+2
 358 00be 9130      		cpi r25,lo8(1)
 359 00c0 01F0      		breq .L18
 360 00c2 9091 0000 		lds r25,sensors+3
 361 00c6 9130      		cpi r25,lo8(1)
 362 00c8 01F4      		brne .L19
 363               	.L18:
 120:proj1.c       **** 		   		safe=1; // unsafe to drive
 364               		.loc 1 120 0 is_stmt 1
 365 00ca F092 0000 		sts safe,r15
 366 00ce 00C0      		rjmp .L20
 367               	.L19:
 122:proj1.c       **** 			else if(sensors[SenBumpDrop]==1 || sensors[SenBumpDrop]==2 || sensors[SenBumpDrop]==3) {
 368               		.loc 1 122 0
 369 00d0 9FEF      		ldi r25,lo8(-1)
 370 00d2 980F      		add r25,r24
 371 00d4 9330      		cpi r25,lo8(3)
 372 00d6 00F0      		brlo .L18
 125:proj1.c       **** 			else safe=0; // safe case
 373               		.loc 1 125 0
 374 00d8 1092 0000 		sts safe,__zero_reg__
 375               	.L20:
 126:proj1.c       **** 			if(sensors[SenBumpDrop]==4 || sensors[SenBumpDrop]==8 || sensors[SenBumpDrop]==16 || sensors[Sen
 376               		.loc 1 126 0
 377 00dc 8430      		cpi r24,lo8(4)
 378 00de 01F0      		breq .L21
 126:proj1.c       **** 			if(sensors[SenBumpDrop]==4 || sensors[SenBumpDrop]==8 || sensors[SenBumpDrop]==16 || sensors[Sen
 379               		.loc 1 126 0 is_stmt 0 discriminator 1
 380 00e0 8830      		cpi r24,lo8(8)
 381 00e2 01F0      		breq .L21
 382 00e4 8031      		cpi r24,lo8(16)
 383 00e6 01F0      		breq .L21
 384 00e8 8C31      		cpi r24,lo8(28)
 385 00ea 01F4      		brne .L22
 386               	.L21:
 127:proj1.c       **** 				unsafeRotate=1; // wheel drop, cannot rotate
 387               		.loc 1 127 0 is_stmt 1
 388 00ec F092 0000 		sts unsafeRotate,r15
 389 00f0 00C0      		rjmp .L23
 390               	.L22:
 129:proj1.c       **** 			else unsafeRotate=0;
 391               		.loc 1 129 0
 392 00f2 1092 0000 		sts unsafeRotate,__zero_reg__
 393               	.L23:
 131:proj1.c       **** 			senseTimerCount=100;
 394               		.loc 1 131 0
 395 00f6 1093 0000 		sts senseTimerCount+1,r17
 396 00fa 0093 0000 		sts senseTimerCount,r16
 132:proj1.c       **** 			canSense=0;
 397               		.loc 1 132 0
 398 00fe 1092 0000 		sts canSense,__zero_reg__
 399               	.LVL52:
 400               	.L13:
 401               	.LBE10:
 136:proj1.c       **** 		if(isRotating==1 && unsafeRotate==1){//do jackShit
 402               		.loc 1 136 0
 403 0102 8091 0000 		lds r24,isRotating
 404 0106 8130      		cpi r24,lo8(1)
 405 0108 01F4      		brne .L24
 136:proj1.c       **** 		if(isRotating==1 && unsafeRotate==1){//do jackShit
 406               		.loc 1 136 0 is_stmt 0 discriminator 1
 407 010a 8091 0000 		lds r24,unsafeRotate
 408 010e 8130      		cpi r24,lo8(1)
 409 0110 01F0      		breq .L25
 410               	.L24:
 139:proj1.c       **** 		else if(sensors[SenIRChar]==130&&safe==0) { // forward
 411               		.loc 1 139 0 is_stmt 1
 412 0112 8091 0000 		lds r24,sensors+10
 413 0116 8238      		cpi r24,lo8(-126)
 414 0118 01F4      		brne .L26
 139:proj1.c       **** 		else if(sensors[SenIRChar]==130&&safe==0) { // forward
 415               		.loc 1 139 0 is_stmt 0 discriminator 1
 416 011a 8091 0000 		lds r24,safe
 417 011e 8111      		cpse r24,__zero_reg__
 418 0120 00C0      		rjmp .L27
 140:proj1.c       **** 		driveStraightDistance();
 419               		.loc 1 140 0 is_stmt 1
 420 0122 0E94 0000 		call driveStraightDistance
 421               	.LVL53:
 422 0126 00C0      		rjmp .L25
 423               	.L26:
 143:proj1.c       **** 		else if(sensors[SenIRChar]==131&&unsafeRotate==0) { // rotate right
 424               		.loc 1 143 0
 425 0128 8338      		cpi r24,lo8(-125)
 426 012a 01F4      		brne .L28
 143:proj1.c       **** 		else if(sensors[SenIRChar]==131&&unsafeRotate==0) { // rotate right
 427               		.loc 1 143 0 is_stmt 0 discriminator 1
 428 012c 8091 0000 		lds r24,unsafeRotate
 429 0130 8111      		cpse r24,__zero_reg__
 430 0132 00C0      		rjmp .L27
 144:proj1.c       **** 		rotateDegreeRight(1);
 431               		.loc 1 144 0 is_stmt 1
 432 0134 81E0      		ldi r24,lo8(1)
 433 0136 90E0      		ldi r25,0
 434 0138 00C0      		rjmp .L52
 435               	.L28:
 147:proj1.c       **** 		else if(sensors[SenIRChar]==129&&unsafeRotate==0) { // rotate left
 436               		.loc 1 147 0
 437 013a 8138      		cpi r24,lo8(-127)
 438 013c 01F4      		brne .L27
 147:proj1.c       **** 		else if(sensors[SenIRChar]==129&&unsafeRotate==0) { // rotate left
 439               		.loc 1 147 0 is_stmt 0 discriminator 1
 440 013e 8091 0000 		lds r24,unsafeRotate
 441 0142 8111      		cpse r24,__zero_reg__
 442 0144 00C0      		rjmp .L27
 148:proj1.c       **** 		rotateDegreeRight(0);
 443               		.loc 1 148 0 is_stmt 1
 444 0146 80E0      		ldi r24,0
 445 0148 90E0      		ldi r25,0
 446               	.L52:
 447 014a 0E94 0000 		call rotateDegreeRight
 448               	.LVL54:
 449 014e 00C0      		rjmp .L25
 450               	.L27:
 151:proj1.c       **** 		else stop();
 451               		.loc 1 151 0
 452 0150 0E94 0000 		call stop
 453               	.LVL55:
 454               	.L25:
 153:proj1.c       **** 		delayMs(15);
 455               		.loc 1 153 0
 456 0154 8FE0      		ldi r24,lo8(15)
 457 0156 90E0      		ldi r25,0
 458 0158 0E94 0000 		call delayMs
 459               	.LVL56:
 154:proj1.c       **** 		if(UserButtonPressed) {
 460               		.loc 1 154 0
 461 015c 4C99      		sbic 0x9,4
 462 015e 00C0      		rjmp .L30
 155:proj1.c       **** 			powerOffRobot();
 463               		.loc 1 155 0
 464 0160 0E94 0000 		call powerOffRobot
 465               	.LVL57:
 156:proj1.c       **** 			exit(1);
 466               		.loc 1 156 0
 467 0164 81E0      		ldi r24,lo8(1)
 468 0166 90E0      		ldi r25,0
 469 0168 0E94 0000 		call exit
 470               	.LVL58:
 471               		.cfi_endproc
 472               	.LFE1:
 474               	.global	isRotating
 475               		.section .bss
 478               	isRotating:
 479 0000 00        		.zero	1
 480               	.global	unsafeRotate
 483               	unsafeRotate:
 484 0001 00        		.zero	1
 485               	.global	safe
 488               	safe:
 489 0002 00        		.zero	1
 490               		.comm	sensors,52,1
 491               	.global	false
 494               	false:
 495 0003 0000      		.zero	2
 496               	.global	true
 497               		.data
 500               	true:
 501 0000 0100      		.word	1
 502               	.global	PI
 505               	PI:
 506 0002 DB        		.byte	-37
 507 0003 0F        		.byte	15
 508 0004 49        		.byte	73
 509 0005 40        		.byte	64
 510               		.comm	notReadyBool,1,1
 511               		.comm	DELAY,2,1
 512               		.text
 513               	.Letext0:
 514               		.file 2 "/usr/lib/avr/include/stdint.h"
 515               		.file 3 "timer.h"
 516               		.file 4 "cmod.h"
 517               		.file 5 "iroblib.h"
 518               		.file 6 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 proj1.c
     /tmp/cc15s578.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc15s578.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc15s578.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc15s578.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc15s578.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc15s578.s:12     .text:0000000000000000 stop
     /tmp/cc15s578.s:46     .text:000000000000001e printBuffer
     /tmp/cc15s578.s:117    .text:000000000000005a rotateDegreeRight
     /tmp/cc15s578.s:488    .bss:0000000000000002 safe
     /tmp/cc15s578.s:478    .bss:0000000000000000 isRotating
     /tmp/cc15s578.s:188    .text:00000000000000aa driveStraightDistance
     /tmp/cc15s578.s:222    .text.startup:0000000000000000 main
                            *COM*:0000000000000002 DELAY
                            *COM*:0000000000000001 notReadyBool
                            *COM*:0000000000000034 sensors
     /tmp/cc15s578.s:483    .bss:0000000000000001 unsafeRotate
     /tmp/cc15s578.s:494    .bss:0000000000000003 false
     /tmp/cc15s578.s:500    .data:0000000000000000 true
     /tmp/cc15s578.s:505    .data:0000000000000002 PI

UNDEFINED SYMBOLS
byteTx
delayMs
initializeCommandModule
powerOnRobot
baud
defineSongs
canSense
byteRx
senseTimerCount
powerOffRobot
exit
__do_copy_data
__do_clear_bss

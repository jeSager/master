   1               		.file	"timer.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_18
  12               	__vector_18:
  13               	.LFB0:
  14               		.file 1 "timer.c"
   1:timer.c       **** //TIMER FOR TASK 1
   2:timer.c       **** 
   3:timer.c       **** #include "timer.h"    // Declaration made available here
   4:timer.c       **** 
   5:timer.c       **** 
   6:timer.c       **** // Timer variables defined here
   7:timer.c       **** 
   8:timer.c       **** // Definition checked against declaration
   9:timer.c       **** volatile uint16_t delayTimerCount = 0;
  10:timer.c       **** 
  11:timer.c       **** // Definition checked against declaration
  12:timer.c       **** volatile uint8_t  delayTimerRunning = 0;
  13:timer.c       **** 
  14:timer.c       **** volatile uint8_t canPrint=0;
  15:timer.c       **** volatile uint16_t senseTimerCount=100;
  16:timer.c       **** volatile uint8_t canSense=0;
  17:timer.c       **** 
  18:timer.c       **** ISR(USART_RX_vect) {  //SIGNAL(SIG_USART_RECV) 
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28               	/* prologue: Signal */
  29               	/* frame size = 0 */
  30               	/* stack size = 3 */
  31               	.L__stack_usage = 3
  32               	/* epilogue start */
  19:timer.c       ****   // Serial receive interrupt to store sensor values
  20:timer.c       ****   
  21:timer.c       ****   // CSCE 274 students, I have only ever used this method 
  22:timer.c       ****   // when retrieving/storing a large amount of sensor data. 
  23:timer.c       ****   // You DO NOT need it for this assignment. If i feel it 
  24:timer.c       ****   // becomes relevant, I will show you how/when to use it.
  25:timer.c       **** }
  33               		.loc 1 25 0
  34 000a 0F90      		pop r0
  35 000c 0FBE      		out __SREG__,r0
  36 000e 0F90      		pop r0
  37 0010 1F90      		pop r1
  38 0012 1895      		reti
  39               		.cfi_endproc
  40               	.LFE0:
  42               	.global	__vector_14
  44               	__vector_14:
  45               	.LFB1:
  26:timer.c       **** 
  27:timer.c       **** //SIGNAL(SIG_OUTPUT_COMPARE1A)
  28:timer.c       **** ISR(TIMER0_COMPA_vect) {
  46               		.loc 1 28 0
  47               		.cfi_startproc
  48 0014 1F92      		push r1
  49               	.LCFI2:
  50               		.cfi_def_cfa_offset 3
  51               		.cfi_offset 1, -2
  52 0016 0F92      		push r0
  53               	.LCFI3:
  54               		.cfi_def_cfa_offset 4
  55               		.cfi_offset 0, -3
  56 0018 0FB6      		in r0,__SREG__
  57 001a 0F92      		push r0
  58 001c 1124      		clr __zero_reg__
  59 001e 8F93      		push r24
  60               	.LCFI4:
  61               		.cfi_def_cfa_offset 5
  62               		.cfi_offset 24, -4
  63 0020 9F93      		push r25
  64               	.LCFI5:
  65               		.cfi_def_cfa_offset 6
  66               		.cfi_offset 25, -5
  67               	/* prologue: Signal */
  68               	/* frame size = 0 */
  69               	/* stack size = 5 */
  70               	.L__stack_usage = 5
  29:timer.c       ****   // Interrupt handler called every 1ms.
  30:timer.c       ****   // Decrement the counter variable, to allow delayMs to keep time.
  31:timer.c       ****   if(delayTimerCount != 0) {
  71               		.loc 1 31 0
  72 0022 8091 0000 		lds r24,delayTimerCount
  73 0026 9091 0000 		lds r25,delayTimerCount+1
  74 002a 892B      		or r24,r25
  75 002c 01F0      		breq .L3
  32:timer.c       ****     delayTimerCount--;
  76               		.loc 1 32 0
  77 002e 8091 0000 		lds r24,delayTimerCount
  78 0032 9091 0000 		lds r25,delayTimerCount+1
  79 0036 0197      		sbiw r24,1
  80 0038 9093 0000 		sts delayTimerCount+1,r25
  81 003c 8093 0000 		sts delayTimerCount,r24
  82 0040 00C0      		rjmp .L4
  83               	.L3:
  33:timer.c       ****   } else {
  34:timer.c       ****     delayTimerRunning = 0;
  84               		.loc 1 34 0
  85 0042 1092 0000 		sts delayTimerRunning,__zero_reg__
  86               	.L4:
  35:timer.c       ****   }
  36:timer.c       **** 
  37:timer.c       ****   if(senseTimerCount !=0) {
  87               		.loc 1 37 0
  88 0046 8091 0000 		lds r24,senseTimerCount
  89 004a 9091 0000 		lds r25,senseTimerCount+1
  90 004e 892B      		or r24,r25
  91 0050 01F0      		breq .L5
  38:timer.c       ****     senseTimerCount--;
  92               		.loc 1 38 0
  93 0052 8091 0000 		lds r24,senseTimerCount
  94 0056 9091 0000 		lds r25,senseTimerCount+1
  95 005a 0197      		sbiw r24,1
  96 005c 9093 0000 		sts senseTimerCount+1,r25
  97 0060 8093 0000 		sts senseTimerCount,r24
  98 0064 00C0      		rjmp .L2
  99               	.L5:
  39:timer.c       ****   } else {
  40:timer.c       ****     canSense =1;
 100               		.loc 1 40 0
 101 0066 81E0      		ldi r24,lo8(1)
 102 0068 8093 0000 		sts canSense,r24
 103               	.L2:
 104               	/* epilogue start */
  41:timer.c       ****   }
  42:timer.c       **** }
 105               		.loc 1 42 0
 106 006c 9F91      		pop r25
 107 006e 8F91      		pop r24
 108 0070 0F90      		pop r0
 109 0072 0FBE      		out __SREG__,r0
 110 0074 0F90      		pop r0
 111 0076 1F90      		pop r1
 112 0078 1895      		reti
 113               		.cfi_endproc
 114               	.LFE1:
 116               	.global	__vector_11
 118               	__vector_11:
 119               	.LFB2:
  43:timer.c       **** 
  44:timer.c       **** ISR(TIMER1_COMPA_vect){
 120               		.loc 1 44 0
 121               		.cfi_startproc
 122 007a 1F92      		push r1
 123               	.LCFI6:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 1, -2
 126 007c 0F92      		push r0
 127               	.LCFI7:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 0, -3
 130 007e 0FB6      		in r0,__SREG__
 131 0080 0F92      		push r0
 132 0082 1124      		clr __zero_reg__
 133 0084 8F93      		push r24
 134               	.LCFI8:
 135               		.cfi_def_cfa_offset 5
 136               		.cfi_offset 24, -4
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 4 */
 140               	.L__stack_usage = 4
  45:timer.c       ****   canPrint=1;
 141               		.loc 1 45 0
 142 0086 81E0      		ldi r24,lo8(1)
 143 0088 8093 0000 		sts canPrint,r24
 144               	/* epilogue start */
  46:timer.c       **** }
 145               		.loc 1 46 0
 146 008c 8F91      		pop r24
 147 008e 0F90      		pop r0
 148 0090 0FBE      		out __SREG__,r0
 149 0092 0F90      		pop r0
 150 0094 1F90      		pop r1
 151 0096 1895      		reti
 152               		.cfi_endproc
 153               	.LFE2:
 155               	.global	setupTimer
 157               	setupTimer:
 158               	.LFB3:
  47:timer.c       **** 
  48:timer.c       **** void setupTimer(void) {
 159               		.loc 1 48 0
 160               		.cfi_startproc
 161               	/* prologue: function */
 162               	/* frame size = 0 */
 163               	/* stack size = 0 */
 164               	.L__stack_usage = 0
  49:timer.c       **** // Set up the timer 1 interupt to be called every 1ms.
  50:timer.c       **** // It's probably best to treat this as a black box.
  51:timer.c       ****   TCCR0A = _BV(WGM01);
 165               		.loc 1 51 0
 166 0098 22E0      		ldi r18,lo8(2)
 167 009a 24BD      		out 0x24,r18
  52:timer.c       ****   TCCR0B = (_BV(CS00) | _BV(CS02));
 168               		.loc 1 52 0
 169 009c 85E0      		ldi r24,lo8(5)
 170 009e 85BD      		out 0x25,r24
  53:timer.c       ****     // TCCR1B = 0x0C;
  54:timer.c       ****   OCR0A = 17;
 171               		.loc 1 54 0
 172 00a0 81E1      		ldi r24,lo8(17)
 173 00a2 87BD      		out 0x27,r24
  55:timer.c       ****   TIMSK0 = _BV(OCIE0A);
 174               		.loc 1 55 0
 175 00a4 2093 6E00 		sts 110,r18
  56:timer.c       ****     // TIMSK1 = 0x02;
  57:timer.c       **** 
  58:timer.c       ****   // Timer 1 setup
  59:timer.c       ****   TCCR1A = 0x00;
 176               		.loc 1 59 0
 177 00a8 1092 8000 		sts 128,__zero_reg__
  60:timer.c       ****   TCCR1B = (_BV(WGM12) | _BV(CS10) | _BV(CS12));
 178               		.loc 1 60 0
 179 00ac 8DE0      		ldi r24,lo8(13)
 180 00ae 8093 8100 		sts 129,r24
  61:timer.c       ****     // TCCR1B = 0x0C;
  62:timer.c       ****   OCR1A = 17999;
 181               		.loc 1 62 0
 182 00b2 8FE4      		ldi r24,lo8(79)
 183 00b4 96E4      		ldi r25,lo8(70)
 184 00b6 9093 8900 		sts 136+1,r25
 185 00ba 8093 8800 		sts 136,r24
  63:timer.c       ****   TIMSK1 = _BV(OCIE1A);
 186               		.loc 1 63 0
 187 00be 2093 6F00 		sts 111,r18
 188 00c2 0895      		ret
 189               		.cfi_endproc
 190               	.LFE3:
 192               	.global	delayMs
 194               	delayMs:
 195               	.LFB4:
  64:timer.c       ****     // TIMSK1 = 0x02;
  65:timer.c       **** 
  66:timer.c       **** 
  67:timer.c       **** }
  68:timer.c       **** 
  69:timer.c       **** // Delay for the specified time in ms without updating sensor values
  70:timer.c       **** void delayMs(uint16_t time_ms)
  71:timer.c       **** {
 196               		.loc 1 71 0
 197               		.cfi_startproc
 198               	.LVL0:
 199               	/* prologue: function */
 200               	/* frame size = 0 */
 201               	/* stack size = 0 */
 202               	.L__stack_usage = 0
  72:timer.c       ****   delayTimerRunning = 1;
 203               		.loc 1 72 0
 204 00c4 21E0      		ldi r18,lo8(1)
 205 00c6 2093 0000 		sts delayTimerRunning,r18
  73:timer.c       ****   delayTimerCount = time_ms;
 206               		.loc 1 73 0
 207 00ca 9093 0000 		sts delayTimerCount+1,r25
 208 00ce 8093 0000 		sts delayTimerCount,r24
 209               	.LVL1:
 210               	.L12:
  74:timer.c       ****   while(delayTimerRunning) ;
 211               		.loc 1 74 0 discriminator 1
 212 00d2 8091 0000 		lds r24,delayTimerRunning
 213 00d6 8111      		cpse r24,__zero_reg__
 214 00d8 00C0      		rjmp .L12
 215               	/* epilogue start */
  75:timer.c       **** }
 216               		.loc 1 75 0
 217 00da 0895      		ret
 218               		.cfi_endproc
 219               	.LFE4:
 221               	.global	canSense
 222               		.section .bss
 225               	canSense:
 226 0000 00        		.zero	1
 227               	.global	senseTimerCount
 228               		.data
 231               	senseTimerCount:
 232 0000 6400      		.word	100
 233               	.global	canPrint
 234               		.section .bss
 237               	canPrint:
 238 0001 00        		.zero	1
 239               	.global	delayTimerRunning
 242               	delayTimerRunning:
 243 0002 00        		.zero	1
 244               	.global	delayTimerCount
 247               	delayTimerCount:
 248 0003 0000      		.zero	2
 249               		.text
 250               	.Letext0:
 251               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 timer.c
     /tmp/ccl7X2k8.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccl7X2k8.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccl7X2k8.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccl7X2k8.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccl7X2k8.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccl7X2k8.s:12     .text:0000000000000000 __vector_18
     /tmp/ccl7X2k8.s:44     .text:0000000000000014 __vector_14
     /tmp/ccl7X2k8.s:247    .bss:0000000000000003 delayTimerCount
     /tmp/ccl7X2k8.s:242    .bss:0000000000000002 delayTimerRunning
     /tmp/ccl7X2k8.s:231    .data:0000000000000000 senseTimerCount
     /tmp/ccl7X2k8.s:225    .bss:0000000000000000 canSense
     /tmp/ccl7X2k8.s:118    .text:000000000000007a __vector_11
     /tmp/ccl7X2k8.s:237    .bss:0000000000000001 canPrint
     /tmp/ccl7X2k8.s:157    .text:0000000000000098 setupTimer
     /tmp/ccl7X2k8.s:194    .text:00000000000000c4 delayMs

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss

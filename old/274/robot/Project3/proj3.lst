   1               		.file	"proj3.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	stop
  12               	stop:
  13               	.LFB2:
  14               		.file 1 "proj3.c"
   1:proj3.c       **** #include "timer.h"
   2:proj3.c       **** #include "cmod.h"
   3:proj3.c       **** #include "iroblib.h"
   4:proj3.c       **** #include "oi.h"
   5:proj3.c       **** #include <stdlib.h>
   6:proj3.c       **** #include <stdio.h>
   7:proj3.c       **** #include <string.h>
   8:proj3.c       **** 
   9:proj3.c       **** // Declare Global variables
  10:proj3.c       **** #define true 1;
  11:proj3.c       **** #define false 0; 
  12:proj3.c       **** uint8_t right= 1;
  13:proj3.c       **** uint8_t left= 0; 
  14:proj3.c       **** uint8_t sensors[Sen6Size]; // Array for all sensor data the robot can send
  15:proj3.c       **** uint16_t state;//[10];
  16:proj3.c       **** uint8_t SETPOINT=80;
  17:proj3.c       **** uint8_t robotState=0;
  18:proj3.c       **** uint8_t startIR=0;
  19:proj3.c       **** // PID Values
  20:proj3.c       **** uint8_t P; // Proportional term
  21:proj3.c       **** uint8_t I; // Integral term
  22:proj3.c       **** uint8_t D; // Derivative term
  23:proj3.c       **** int8_t U; // Control signal
  24:proj3.c       **** uint8_t PGain=80; // Proportional gain
  25:proj3.c       **** uint8_t IGain=20; // Integral gain
  26:proj3.c       **** uint8_t DGain=200; // Derivative gain
  27:proj3.c       **** uint8_t PROPORTIONAL4U=100;//given proportion
  28:proj3.c       **** uint8_t T=1; // Delta t (1ms)
  29:proj3.c       **** uint16_t sum; // Summation for I term
  30:proj3.c       **** uint8_t e[10]; // Error array
  31:proj3.c       **** uint8_t populateArray=0;
  32:proj3.c       **** uint8_t right; // Boolean for turning
  33:proj3.c       **** uint8_t firstStraight=1; // Boolean
  34:proj3.c       **** uint8_t slowTheFuckDown=0; // Boolean
  35:proj3.c       **** 
  36:proj3.c       **** //state avg for straight driving
  37:proj3.c       **** uint16_t stateSum;//summation for stae avg
  38:proj3.c       **** uint16_t avgState;//a variable
  39:proj3.c       **** uint8_t hasTurned=0;//try to drive straight boolean
  40:proj3.c       **** uint8_t s[10];//state array
  41:proj3.c       **** 
  42:proj3.c       **** // Wheel adjustments
  43:proj3.c       **** uint16_t wheelSpeed;
  44:proj3.c       **** uint16_t newSpeed;
  45:proj3.c       **** uint8_t highBit;   
  46:proj3.c       **** uint8_t lowBit;
  47:proj3.c       **** uint16_t leftSpeed;
  48:proj3.c       **** uint8_t highBitLeft;
  49:proj3.c       **** uint8_t lowBitLeft;
  50:proj3.c       **** 
  51:proj3.c       **** // functions
  52:proj3.c       **** int main(void);
  53:proj3.c       **** void printBuffer(char buf[]);
  54:proj3.c       **** void rotate(uint8_t degree, uint8_t r);
  55:proj3.c       **** void driveStraight(void);
  56:proj3.c       **** void stop(void);
  57:proj3.c       **** int findWall(void);
  58:proj3.c       **** void alignWall(void);
  59:proj3.c       **** //void smallCircle(void);
  60:proj3.c       **** void followWall(void);
  61:proj3.c       **** void dock(void);
  62:proj3.c       **** void faceHome(uint8_t right);
  63:proj3.c       **** void driveStraightHome(void);
  64:proj3.c       **** void home(void);
  65:proj3.c       **** //void adjust(void);
  66:proj3.c       **** void driveStraightDistanceCm(int distance);
  67:proj3.c       **** void locate(void);
  68:proj3.c       **** void updateSensors(void);
  69:proj3.c       **** void reverse(void);
  70:proj3.c       **** 
  71:proj3.c       **** uint8_t red;
  72:proj3.c       **** uint8_t green;
  73:proj3.c       **** uint8_t redgreen;
  74:proj3.c       **** uint8_t redgreenforce;
  75:proj3.c       **** uint8_t greenforce;
  76:proj3.c       **** uint8_t redforce;
  77:proj3.c       **** uint8_t goodIR;
  78:proj3.c       **** uint8_t located;
  79:proj3.c       **** uint8_t first=true;
  80:proj3.c       **** uint8_t anyforce;
  81:proj3.c       **** 
  82:proj3.c       **** 
  83:proj3.c       **** int main(void) {
  84:proj3.c       **** // Set up Create and module
  85:proj3.c       **** initializeCommandModule();
  86:proj3.c       **** 
  87:proj3.c       **** powerOnRobot();
  88:proj3.c       **** // Is the Robot on
  89:proj3.c       **** byteTx(CmdStart);
  90:proj3.c       **** // Start the create
  91:proj3.c       **** baud(Baud57600);
  92:proj3.c       **** // Set the baud rate for the Create and Command Module
  93:proj3.c       **** defineSongs();
  94:proj3.c       **** // Define some songs so that we know the robot is on.
  95:proj3.c       **** byteTx(CmdControl);
  96:proj3.c       **** // Deprecated form of safe mode. I use it because it will
  97:proj3.c       **** // turn of all LEDs, so it's essentially a reset.
  98:proj3.c       **** byteTx(CmdFull);
  99:proj3.c       **** // We are operating in FULL mode.
 100:proj3.c       **** 
 101:proj3.c       **** // CSCE 274 students: I would make sure the robot stops. 
 102:proj3.c       **** //                    As a precaution for the robot and your grade.
 103:proj3.c       **** 
 104:proj3.c       **** // Play the reset song and wait while it plays.
 105:proj3.c       **** byteTx(CmdPlay);
 106:proj3.c       **** byteTx(RESET_SONG);
 107:proj3.c       **** delayMs(750);
 108:proj3.c       **** 
 109:proj3.c       **** // Turn the power button on to something. I like red, but here is green.
 110:proj3.c       **** // CSCE 274 students: The following should (will) be a function that you write.
 111:proj3.c       **** byteTx(CmdLeds);
 112:proj3.c       **** byteTx(0x00);
 113:proj3.c       **** byteTx(0);
 114:proj3.c       **** byteTx(255);
 115:proj3.c       **** 
 116:proj3.c       **** // Infinite operation loop
 117:proj3.c       **** for(;;) {
 118:proj3.c       **** updateSensors();
 119:proj3.c       **** 
 120:proj3.c       **** 
 121:proj3.c       **** if(sensors[SenBumpDrop]<=4) {
 122:proj3.c       **** 	if(robotState==3)
 123:proj3.c       **** 		dock();
 124:proj3.c       **** 	else 
 125:proj3.c       **** 	if (robotState==0)// no wall, drive straight
 126:proj3.c       **** 		driveStraight();
 127:proj3.c       **** 	else if (robotState==1) { // on wall, stop and rotate
 128:proj3.c       **** 		stop();
 129:proj3.c       **** 		rotate(5,left);
 130:proj3.c       **** 	}
 131:proj3.c       **** 	else if (robotState==2){
 132:proj3.c       **** 	followWall();
 133:proj3.c       **** 	hasTurned=1;
 134:proj3.c       **** 	}
 135:proj3.c       **** 	
 136:proj3.c       **** } // wheel drop detection
 137:proj3.c       **** else
 138:proj3.c       **** 	stop();
 139:proj3.c       **** 
 140:proj3.c       **** delayMs(15);
 141:proj3.c       **** if(UserButtonPressed) {
 142:proj3.c       **** 	powerOffRobot();
 143:proj3.c       **** 	exit(1);
 144:proj3.c       **** 	}//endif
 145:proj3.c       **** }//endfor
 146:proj3.c       **** }//end main
 147:proj3.c       **** 
 148:proj3.c       **** void stop(void) {
  15               		.loc 1 148 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 149:proj3.c       **** 	byteTx(CmdDriveWheels);
  21               		.loc 1 149 0
  22 0000 81E9      		ldi r24,lo8(-111)
  23 0002 0E94 0000 		call byteTx
  24               	.LVL0:
 150:proj3.c       **** 	byteTx(0x00);//velocity right wheel 0mm/s
  25               		.loc 1 150 0
  26 0006 80E0      		ldi r24,0
  27 0008 0E94 0000 		call byteTx
  28               	.LVL1:
 151:proj3.c       **** 	byteTx(0x00);
  29               		.loc 1 151 0
  30 000c 80E0      		ldi r24,0
  31 000e 0E94 0000 		call byteTx
  32               	.LVL2:
 152:proj3.c       **** 	byteTx(0x00);//velocity left wheel 0mm/s
  33               		.loc 1 152 0
  34 0012 80E0      		ldi r24,0
  35 0014 0E94 0000 		call byteTx
  36               	.LVL3:
 153:proj3.c       **** 	byteTx(0x00);
  37               		.loc 1 153 0
  38 0018 80E0      		ldi r24,0
  39 001a 0C94 0000 		jmp byteTx
  40               	.LVL4:
  41               		.cfi_endproc
  42               	.LFE2:
  44               	.global	rotate
  46               	rotate:
  47               	.LFB3:
 154:proj3.c       **** 	}
 155:proj3.c       **** 
 156:proj3.c       **** void rotate(uint8_t degree, uint8_t r){//r for right
  48               		.loc 1 156 0
  49               		.cfi_startproc
  50               	.LVL5:
  51 001e 0F93      		push r16
  52               	.LCFI0:
  53               		.cfi_def_cfa_offset 3
  54               		.cfi_offset 16, -2
  55 0020 1F93      		push r17
  56               	.LCFI1:
  57               		.cfi_def_cfa_offset 4
  58               		.cfi_offset 17, -3
  59 0022 CF93      		push r28
  60               	.LCFI2:
  61               		.cfi_def_cfa_offset 5
  62               		.cfi_offset 28, -4
  63 0024 DF93      		push r29
  64               	.LCFI3:
  65               		.cfi_def_cfa_offset 6
  66               		.cfi_offset 29, -5
  67 0026 1F92      		push __zero_reg__
  68               	.LCFI4:
  69               		.cfi_def_cfa_offset 7
  70 0028 CDB7      		in r28,__SP_L__
  71 002a DEB7      		in r29,__SP_H__
  72               	.LCFI5:
  73               		.cfi_def_cfa_register 28
  74               	/* prologue: function */
  75               	/* frame size = 1 */
  76               	/* stack size = 5 */
  77               	.L__stack_usage = 5
 157:proj3.c       **** 	int rotateDelayMs = degree*8;//gives proper degree at 30cm/s
  78               		.loc 1 157 0
  79 002c 98E0      		ldi r25,lo8(8)
  80 002e 899F      		mul r24,r25
  81 0030 8001      		movw r16,r0
  82 0032 1124      		clr __zero_reg__
  83               	.LVL6:
 158:proj3.c       **** 	byteTx(CmdDriveWheels);	
  84               		.loc 1 158 0
  85 0034 81E9      		ldi r24,lo8(-111)
  86               	.LVL7:
  87 0036 6983      		std Y+1,r22
  88 0038 0E94 0000 		call byteTx
  89               	.LVL8:
 159:proj3.c       **** 	if(r){
  90               		.loc 1 159 0
  91 003c 6981      		ldd r22,Y+1
  92 003e 6623      		tst r22
  93 0040 01F0      		breq .L3
 160:proj3.c       **** 	byteTx(0xfe);//velocity right wheel
  94               		.loc 1 160 0
  95 0042 8EEF      		ldi r24,lo8(-2)
  96 0044 0E94 0000 		call byteTx
  97               	.LVL9:
 161:proj3.c       **** 	byteTx(0xd4);
  98               		.loc 1 161 0
  99 0048 84ED      		ldi r24,lo8(-44)
 100 004a 0E94 0000 		call byteTx
 101               	.LVL10:
 162:proj3.c       **** 	byteTx(0x01);//velocity left wheel 
 102               		.loc 1 162 0
 103 004e 81E0      		ldi r24,lo8(1)
 104 0050 0E94 0000 		call byteTx
 105               	.LVL11:
 163:proj3.c       **** 	byteTx(0x2c);
 106               		.loc 1 163 0
 107 0054 8CE2      		ldi r24,lo8(44)
 108 0056 00C0      		rjmp .L5
 109               	.L3:
 164:proj3.c       **** 	}	
 165:proj3.c       **** 
 166:proj3.c       **** 	else{
 167:proj3.c       **** 	byteTx(0x01);//velocity right wheel
 110               		.loc 1 167 0
 111 0058 81E0      		ldi r24,lo8(1)
 112 005a 0E94 0000 		call byteTx
 113               	.LVL12:
 168:proj3.c       **** 	byteTx(0x2c);
 114               		.loc 1 168 0
 115 005e 8CE2      		ldi r24,lo8(44)
 116 0060 0E94 0000 		call byteTx
 117               	.LVL13:
 169:proj3.c       **** 	byteTx(0xfe);//velocity left wheel 
 118               		.loc 1 169 0
 119 0064 8EEF      		ldi r24,lo8(-2)
 120 0066 0E94 0000 		call byteTx
 121               	.LVL14:
 170:proj3.c       **** 	byteTx(0xd4);
 122               		.loc 1 170 0
 123 006a 84ED      		ldi r24,lo8(-44)
 124               	.L5:
 125 006c 0E94 0000 		call byteTx
 126               	.LVL15:
 171:proj3.c       **** 	}
 172:proj3.c       **** 	delayMs(rotateDelayMs);
 127               		.loc 1 172 0
 128 0070 C801      		movw r24,r16
 129               	/* epilogue start */
 173:proj3.c       **** 	}
 130               		.loc 1 173 0
 131 0072 0F90      		pop __tmp_reg__
 132 0074 DF91      		pop r29
 133 0076 CF91      		pop r28
 134 0078 1F91      		pop r17
 135 007a 0F91      		pop r16
 136               	.LVL16:
 172:proj3.c       **** 	delayMs(rotateDelayMs);
 137               		.loc 1 172 0
 138 007c 0C94 0000 		jmp delayMs
 139               	.LVL17:
 140               		.cfi_endproc
 141               	.LFE3:
 143               	.global	driveStraightHome
 145               	driveStraightHome:
 146               	.LFB5:
 174:proj3.c       **** 
 175:proj3.c       **** void driveStraight(void){
 176:proj3.c       **** 	if(avgState<=0&&hasTurned==0){
 177:proj3.c       **** 		byteTx(CmdDriveWheels);
 178:proj3.c       **** 		byteTx(0x00);//velocity right wheel 150mm/s
 179:proj3.c       **** 		byteTx(0x99);
 180:proj3.c       **** 		byteTx(0x00);//velocity left wheel 150mm/s
 181:proj3.c       **** 		byteTx(0x99);		
 182:proj3.c       **** 	}
 183:proj3.c       **** 	else{
 184:proj3.c       **** 		byteTx(CmdDriveWheels);
 185:proj3.c       **** 		byteTx(0x00);//velocity right wheel 150mm/s
 186:proj3.c       **** 		byteTx(0x20);
 187:proj3.c       **** 		byteTx(0x00);//velocity left wheel 150mm/s
 188:proj3.c       **** 		byteTx(0x99);
 189:proj3.c       **** 		hasTurned=1;
 190:proj3.c       **** 	}
 191:proj3.c       **** 	robotState=findWall();
 192:proj3.c       **** }
 193:proj3.c       **** 
 194:proj3.c       **** void driveStraightHome(void){
 147               		.loc 1 194 0
 148               		.cfi_startproc
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 0 */
 152               	.L__stack_usage = 0
 195:proj3.c       ****     byteTx(CmdDriveWheels);
 153               		.loc 1 195 0
 154 0080 81E9      		ldi r24,lo8(-111)
 155 0082 0E94 0000 		call byteTx
 156               	.LVL18:
 196:proj3.c       ****     byteTx(0x00); // Velocity right wheel 150mm/s
 157               		.loc 1 196 0
 158 0086 80E0      		ldi r24,0
 159 0088 0E94 0000 		call byteTx
 160               	.LVL19:
 197:proj3.c       ****     byteTx(0x60);
 161               		.loc 1 197 0
 162 008c 80E6      		ldi r24,lo8(96)
 163 008e 0E94 0000 		call byteTx
 164               	.LVL20:
 198:proj3.c       ****     byteTx(0x00); // Velocity left wheel 150mm/s
 165               		.loc 1 198 0
 166 0092 80E0      		ldi r24,0
 167 0094 0E94 0000 		call byteTx
 168               	.LVL21:
 199:proj3.c       ****     byteTx(0x60);
 169               		.loc 1 199 0
 170 0098 80E6      		ldi r24,lo8(96)
 171 009a 0C94 0000 		jmp byteTx
 172               	.LVL22:
 173               		.cfi_endproc
 174               	.LFE5:
 176               	.global	home
 178               	home:
 179               	.LFB6:
 200:proj3.c       **** }//end straight home
 201:proj3.c       **** 
 202:proj3.c       **** void home(void){
 180               		.loc 1 202 0
 181               		.cfi_startproc
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 0 */
 185               	.L__stack_usage = 0
 203:proj3.c       ****     byteTx(CmdDriveWheels);
 186               		.loc 1 203 0
 187 009e 81E9      		ldi r24,lo8(-111)
 188 00a0 0E94 0000 		call byteTx
 189               	.LVL23:
 204:proj3.c       ****     byteTx(0x00); // Velocity right wheel 150mm/s
 190               		.loc 1 204 0
 191 00a4 80E0      		ldi r24,0
 192 00a6 0E94 0000 		call byteTx
 193               	.LVL24:
 205:proj3.c       ****     byteTx(0x20);
 194               		.loc 1 205 0
 195 00aa 80E2      		ldi r24,lo8(32)
 196 00ac 0E94 0000 		call byteTx
 197               	.LVL25:
 206:proj3.c       ****     byteTx(0x00); // Velocity left wheel 150mm/s
 198               		.loc 1 206 0
 199 00b0 80E0      		ldi r24,0
 200 00b2 0E94 0000 		call byteTx
 201               	.LVL26:
 207:proj3.c       ****     byteTx(0x20);
 202               		.loc 1 207 0
 203 00b6 80E2      		ldi r24,lo8(32)
 204 00b8 0C94 0000 		jmp byteTx
 205               	.LVL27:
 206               		.cfi_endproc
 207               	.LFE6:
 209               	.global	faceHome
 211               	faceHome:
 212               	.LFB7:
 208:proj3.c       **** }//end straight home
 209:proj3.c       **** 
 210:proj3.c       **** void faceHome(uint8_t right){
 213               		.loc 1 210 0
 214               		.cfi_startproc
 215               	.LVL28:
 216 00bc CF93      		push r28
 217               	.LCFI6:
 218               		.cfi_def_cfa_offset 3
 219               		.cfi_offset 28, -2
 220               	/* prologue: function */
 221               	/* frame size = 0 */
 222               	/* stack size = 1 */
 223               	.L__stack_usage = 1
 224 00be C82F      		mov r28,r24
 211:proj3.c       ****     byteTx(CmdDriveWheels);
 225               		.loc 1 211 0
 226 00c0 81E9      		ldi r24,lo8(-111)
 227               	.LVL29:
 228 00c2 0E94 0000 		call byteTx
 229               	.LVL30:
 230               	.LBB9:
 231               	.LBB10:
 212:proj3.c       ****     if(right==1){
 213:proj3.c       ****         byteTx(0x00); // Velocity right wheel 300mm/s
 232               		.loc 1 213 0
 233 00c6 80E0      		ldi r24,0
 234               	.LBE10:
 235               	.LBE9:
 212:proj3.c       ****     if(right==1){
 236               		.loc 1 212 0
 237 00c8 C130      		cpi r28,lo8(1)
 238 00ca 01F4      		brne .L10
 239               	.LVL31:
 240               	.LBB12:
 241               	.LBB11:
 242               		.loc 1 213 0
 243 00cc 0E94 0000 		call byteTx
 244               	.LVL32:
 214:proj3.c       ****         byteTx(0x70);
 245               		.loc 1 214 0
 246 00d0 80E7      		ldi r24,lo8(112)
 247 00d2 0E94 0000 		call byteTx
 248               	.LVL33:
 215:proj3.c       ****         byteTx(0x00); // Velocity left wheel -300mm/s
 249               		.loc 1 215 0
 250 00d6 80E0      		ldi r24,0
 251 00d8 0E94 0000 		call byteTx
 252               	.LVL34:
 216:proj3.c       ****         byteTx(0x20);
 253               		.loc 1 216 0
 254 00dc 80E2      		ldi r24,lo8(32)
 255 00de 00C0      		rjmp .L11
 256               	.LVL35:
 257               	.L10:
 258               	.LBE11:
 259               	.LBE12:
 217:proj3.c       ****     }
 218:proj3.c       ****     else{
 219:proj3.c       ****         byteTx(0x00); // Velocity left wheel 300mm/s
 260               		.loc 1 219 0
 261 00e0 0E94 0000 		call byteTx
 262               	.LVL36:
 220:proj3.c       ****         byteTx(0x20);
 263               		.loc 1 220 0
 264 00e4 80E2      		ldi r24,lo8(32)
 265 00e6 0E94 0000 		call byteTx
 266               	.LVL37:
 221:proj3.c       ****         byteTx(0x00); // Velocity right wheel -300mm/s
 267               		.loc 1 221 0
 268 00ea 80E0      		ldi r24,0
 269 00ec 0E94 0000 		call byteTx
 270               	.LVL38:
 222:proj3.c       ****         byteTx(0x70);
 271               		.loc 1 222 0
 272 00f0 80E7      		ldi r24,lo8(112)
 273               	.L11:
 274               	/* epilogue start */
 223:proj3.c       **** 	}
 224:proj3.c       **** 
 225:proj3.c       **** }//end faceHome
 275               		.loc 1 225 0
 276 00f2 CF91      		pop r28
 277               	.LVL39:
 222:proj3.c       ****         byteTx(0x70);
 278               		.loc 1 222 0
 279 00f4 0C94 0000 		jmp byteTx
 280               	.LVL40:
 281               		.cfi_endproc
 282               	.LFE7:
 284               	.global	findWall
 286               	findWall:
 287               	.LFB8:
 226:proj3.c       **** 
 227:proj3.c       **** int findWall(void) {
 288               		.loc 1 227 0
 289               		.cfi_startproc
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 0 */
 293               	.L__stack_usage = 0
 228:proj3.c       **** 	if (sensors[SenBumpDrop]==1 || sensors[SenBumpDrop]==2 || sensors[SenBumpDrop]==3)
 294               		.loc 1 228 0
 295 00f8 2091 0000 		lds r18,sensors
 296 00fc 2150      		subi r18,lo8(-(-1))
 297 00fe 81E0      		ldi r24,lo8(1)
 298 0100 90E0      		ldi r25,0
 299 0102 2330      		cpi r18,lo8(3)
 300 0104 00F0      		brlo .L13
 301 0106 80E0      		ldi r24,0
 302 0108 90E0      		ldi r25,0
 303               	.L13:
 229:proj3.c       **** 		return 1; // 1 is wall found
 230:proj3.c       **** 	else return 0; // 0 is wall not found
 231:proj3.c       **** }
 304               		.loc 1 231 0
 305 010a 0895      		ret
 306               		.cfi_endproc
 307               	.LFE8:
 309               	.global	driveStraight
 311               	driveStraight:
 312               	.LFB4:
 175:proj3.c       **** void driveStraight(void){
 313               		.loc 1 175 0
 314               		.cfi_startproc
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 0 */
 318               	.L__stack_usage = 0
 176:proj3.c       **** 	if(avgState<=0&&hasTurned==0){
 319               		.loc 1 176 0
 320 010c 8091 0000 		lds r24,avgState
 321 0110 9091 0000 		lds r25,avgState+1
 322 0114 892B      		or r24,r25
 323 0116 01F4      		brne .L15
 176:proj3.c       **** 	if(avgState<=0&&hasTurned==0){
 324               		.loc 1 176 0 is_stmt 0 discriminator 1
 325 0118 8091 0000 		lds r24,hasTurned
 326 011c 8111      		cpse r24,__zero_reg__
 327 011e 00C0      		rjmp .L15
 177:proj3.c       **** 		byteTx(CmdDriveWheels);
 328               		.loc 1 177 0 is_stmt 1
 329 0120 81E9      		ldi r24,lo8(-111)
 330 0122 0E94 0000 		call byteTx
 331               	.LVL41:
 178:proj3.c       **** 		byteTx(0x00);//velocity right wheel 150mm/s
 332               		.loc 1 178 0
 333 0126 80E0      		ldi r24,0
 334 0128 0E94 0000 		call byteTx
 335               	.LVL42:
 179:proj3.c       **** 		byteTx(0x99);
 336               		.loc 1 179 0
 337 012c 89E9      		ldi r24,lo8(-103)
 338 012e 0E94 0000 		call byteTx
 339               	.LVL43:
 180:proj3.c       **** 		byteTx(0x00);//velocity left wheel 150mm/s
 340               		.loc 1 180 0
 341 0132 80E0      		ldi r24,0
 342 0134 0E94 0000 		call byteTx
 343               	.LVL44:
 181:proj3.c       **** 		byteTx(0x99);		
 344               		.loc 1 181 0
 345 0138 89E9      		ldi r24,lo8(-103)
 346 013a 0E94 0000 		call byteTx
 347               	.LVL45:
 348 013e 00C0      		rjmp .L16
 349               	.L15:
 184:proj3.c       **** 		byteTx(CmdDriveWheels);
 350               		.loc 1 184 0
 351 0140 81E9      		ldi r24,lo8(-111)
 352 0142 0E94 0000 		call byteTx
 353               	.LVL46:
 185:proj3.c       **** 		byteTx(0x00);//velocity right wheel 150mm/s
 354               		.loc 1 185 0
 355 0146 80E0      		ldi r24,0
 356 0148 0E94 0000 		call byteTx
 357               	.LVL47:
 186:proj3.c       **** 		byteTx(0x20);
 358               		.loc 1 186 0
 359 014c 80E2      		ldi r24,lo8(32)
 360 014e 0E94 0000 		call byteTx
 361               	.LVL48:
 187:proj3.c       **** 		byteTx(0x00);//velocity left wheel 150mm/s
 362               		.loc 1 187 0
 363 0152 80E0      		ldi r24,0
 364 0154 0E94 0000 		call byteTx
 365               	.LVL49:
 188:proj3.c       **** 		byteTx(0x99);
 366               		.loc 1 188 0
 367 0158 89E9      		ldi r24,lo8(-103)
 368 015a 0E94 0000 		call byteTx
 369               	.LVL50:
 189:proj3.c       **** 		hasTurned=1;
 370               		.loc 1 189 0
 371 015e 81E0      		ldi r24,lo8(1)
 372 0160 8093 0000 		sts hasTurned,r24
 373               	.L16:
 191:proj3.c       **** 	robotState=findWall();
 374               		.loc 1 191 0
 375 0164 0E94 0000 		call findWall
 376               	.LVL51:
 377 0168 8093 0000 		sts robotState,r24
 378 016c 0895      		ret
 379               		.cfi_endproc
 380               	.LFE4:
 382               	.global	followWall
 384               	followWall:
 385               	.LFB9:
 232:proj3.c       **** 
 233:proj3.c       **** void followWall(void) {
 386               		.loc 1 233 0
 387               		.cfi_startproc
 388               	/* prologue: function */
 389               	/* frame size = 0 */
 390               	/* stack size = 0 */
 391               	.L__stack_usage = 0
 234:proj3.c       **** 	wheelSpeed=0x96;
 392               		.loc 1 234 0
 393 016e 26E9      		ldi r18,lo8(-106)
 394 0170 30E0      		ldi r19,0
 395 0172 3093 0000 		sts wheelSpeed+1,r19
 396 0176 2093 0000 		sts wheelSpeed,r18
 235:proj3.c       **** 	leftSpeed=wheelSpeed-U;//16bit
 397               		.loc 1 235 0
 398 017a 8091 0000 		lds r24,U
 399 017e 9927      		clr r25
 400 0180 87FD      		sbrc r24,7
 401 0182 9095      		com r25
 402 0184 281B      		sub r18,r24
 403 0186 390B      		sbc r19,r25
 404 0188 3093 0000 		sts leftSpeed+1,r19
 405 018c 2093 0000 		sts leftSpeed,r18
 236:proj3.c       **** 	highBitLeft=leftSpeed>>8;
 406               		.loc 1 236 0
 407 0190 3093 0000 		sts highBitLeft,r19
 237:proj3.c       **** 	lowBitLeft=leftSpeed-(highBitLeft<<8);
 408               		.loc 1 237 0
 409 0194 2093 0000 		sts lowBitLeft,r18
 238:proj3.c       **** 	newSpeed=wheelSpeed+U;//16bit
 410               		.loc 1 238 0
 411 0198 8A56      		subi r24,106
 412 019a 9F4F      		sbci r25,-1
 413 019c 9093 0000 		sts newSpeed+1,r25
 414 01a0 8093 0000 		sts newSpeed,r24
 239:proj3.c       **** 	highBit=newSpeed>>8;   
 415               		.loc 1 239 0
 416 01a4 9093 0000 		sts highBit,r25
 240:proj3.c       **** 	lowBit=newSpeed-(highBit<<8);
 417               		.loc 1 240 0
 418 01a8 8093 0000 		sts lowBit,r24
 241:proj3.c       **** 	byteTx(CmdDriveWheels);
 419               		.loc 1 241 0
 420 01ac 81E9      		ldi r24,lo8(-111)
 421 01ae 0E94 0000 		call byteTx
 422               	.LVL52:
 242:proj3.c       **** 	byteTx(highBit);//velocity right wheel 150mm/s+u
 423               		.loc 1 242 0
 424 01b2 8091 0000 		lds r24,highBit
 425 01b6 0E94 0000 		call byteTx
 426               	.LVL53:
 243:proj3.c       **** 	byteTx(lowBit);
 427               		.loc 1 243 0
 428 01ba 8091 0000 		lds r24,lowBit
 429 01be 0E94 0000 		call byteTx
 430               	.LVL54:
 244:proj3.c       **** 	//left stays constant
 245:proj3.c       **** 	byteTx(highBitLeft);//velocity left wheel 150mm/s
 431               		.loc 1 245 0
 432 01c2 8091 0000 		lds r24,highBitLeft
 433 01c6 0E94 0000 		call byteTx
 434               	.LVL55:
 246:proj3.c       **** 	byteTx(lowBitLeft);
 435               		.loc 1 246 0
 436 01ca 8091 0000 		lds r24,lowBitLeft
 437 01ce 0C94 0000 		jmp byteTx
 438               	.LVL56:
 439               		.cfi_endproc
 440               	.LFE9:
 442               	.global	reverse
 444               	reverse:
 445               	.LFB11:
 247:proj3.c       **** }
 248:proj3.c       **** 
 249:proj3.c       **** void dock(void) {
 250:proj3.c       **** 
 251:proj3.c       **** 
 252:proj3.c       **** 
 253:proj3.c       **** /*
 254:proj3.c       **** if(sensors[SenChAvailable]!=0)
 255:proj3.c       **** 	stop();
 256:proj3.c       **** 
 257:proj3.c       **** if(sensors[SenBumpDrop]>0 && sensors[SenIRChar]==254)
 258:proj3.c       **** 	adjust();
 259:proj3.c       **** 
 260:proj3.c       **** if(sensors[SenBumpDrop]>0 && sensors[SenIRChar]==246)
 261:proj3.c       **** 	adjust();
 262:proj3.c       **** 
 263:proj3.c       **** if(sensors[SenBumpDrop]>0 && sensors[SenIRChar]==250)
 264:proj3.c       **** 	adjust();
 265:proj3.c       **** 
 266:proj3.c       **** if(sensors[SenBumpDrop]>0 && sensors[SenIRChar]==242)
 267:proj3.c       **** 	adjust();
 268:proj3.c       **** */
 269:proj3.c       **** 
 270:proj3.c       **** 
 271:proj3.c       **** 
 272:proj3.c       **** /*
 273:proj3.c       **** else if(redgreen){
 274:proj3.c       **** 	located=true;
 275:proj3.c       **** 	driveStraightHome();
 276:proj3.c       **** }*/
 277:proj3.c       **** 
 278:proj3.c       **** if(first){
 279:proj3.c       **** 	rotate(90, left);
 280:proj3.c       **** 	first=false;
 281:proj3.c       **** 	while(sensors[SenBumpDrop]!=0){
 282:proj3.c       **** 		rotate(5,left);
 283:proj3.c       **** 		updateSensors();		
 284:proj3.c       **** 	}
 285:proj3.c       **** }
 286:proj3.c       **** while(1){
 287:proj3.c       **** updateSensors();
 288:proj3.c       **** //movement
 289:proj3.c       **** if(sensors[SenBumpDrop]!=0){
 290:proj3.c       **** 
 291:proj3.c       **** 	byteTx(CmdSafe);
 292:proj3.c       **** 	stop();
 293:proj3.c       **** 	delayMs(5000);
 294:proj3.c       **** 	updateSensors();
 295:proj3.c       **** 
 296:proj3.c       **** 	if(sensors[SenBumpDrop]!=0){
 297:proj3.c       **** 		reverse();
 298:proj3.c       **** 	}
 299:proj3.c       **** }
 300:proj3.c       **** else if(red||redforce)//red
 301:proj3.c       **** 	faceHome(right);
 302:proj3.c       **** else if(green||greenforce)//green
 303:proj3.c       **** 	faceHome(left);
 304:proj3.c       **** else
 305:proj3.c       **** 	driveStraightHome();
 306:proj3.c       **** }
 307:proj3.c       **** 	
 308:proj3.c       **** 
 309:proj3.c       **** 
 310:proj3.c       **** }
 311:proj3.c       **** 
 312:proj3.c       **** 
 313:proj3.c       **** void reverse(void){
 446               		.loc 1 313 0
 447               		.cfi_startproc
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 0 */
 451               	.L__stack_usage = 0
 314:proj3.c       **** 	byteTx(CmdDriveWheels);
 452               		.loc 1 314 0
 453 01d2 81E9      		ldi r24,lo8(-111)
 454 01d4 0E94 0000 		call byteTx
 455               	.LVL57:
 315:proj3.c       **** 	byteTx(0xff); //backwards
 456               		.loc 1 315 0
 457 01d8 8FEF      		ldi r24,lo8(-1)
 458 01da 0E94 0000 		call byteTx
 459               	.LVL58:
 316:proj3.c       **** 	byteTx(0x06);
 460               		.loc 1 316 0
 461 01de 86E0      		ldi r24,lo8(6)
 462 01e0 0E94 0000 		call byteTx
 463               	.LVL59:
 317:proj3.c       **** 	byteTx(0xff);
 464               		.loc 1 317 0
 465 01e4 8FEF      		ldi r24,lo8(-1)
 466 01e6 0E94 0000 		call byteTx
 467               	.LVL60:
 318:proj3.c       **** 	byteTx(0x06);
 468               		.loc 1 318 0
 469 01ea 86E0      		ldi r24,lo8(6)
 470 01ec 0E94 0000 		call byteTx
 471               	.LVL61:
 319:proj3.c       **** 	delayMs(2000);
 472               		.loc 1 319 0
 473 01f0 80ED      		ldi r24,lo8(-48)
 474 01f2 97E0      		ldi r25,lo8(7)
 475 01f4 0E94 0000 		call delayMs
 476               	.LVL62:
 320:proj3.c       **** 	stop();
 477               		.loc 1 320 0
 478 01f8 0C94 0000 		jmp stop
 479               	.LVL63:
 480               		.cfi_endproc
 481               	.LFE11:
 483               	.global	driveStraightDistanceCm
 485               	driveStraightDistanceCm:
 486               	.LFB12:
 321:proj3.c       **** //	locate();
 322:proj3.c       **** }
 323:proj3.c       **** /*
 324:proj3.c       **** void locate(void){-
 325:proj3.c       **** 	uint8_t next=false;
 326:proj3.c       **** 	if(!(redgreen||redgreenforce)){
 327:proj3.c       **** 		stop();
 328:proj3.c       **** 		rotate(20, left);
 329:proj3.c       **** 		updateSensors();
 330:proj3.c       **** 		delayMs(250);
 331:proj3.c       **** 		stop();
 332:proj3.c       **** 		if(!(redgreen||redgreenforce)){	
 333:proj3.c       **** 			rotate(40, right);
 334:proj3.c       **** 			updateSensors();
 335:proj3.c       **** 			delayMs(250);
 336:proj3.c       **** 			stop();
 337:proj3.c       **** 		}
 338:proj3.c       **** 	}
 339:proj3.c       **** 	if(!goodIR){
 340:proj3.c       **** 		robotState=0;
 341:proj3.c       **** 	}
 342:proj3.c       **** }*/
 343:proj3.c       **** /*
 344:proj3.c       **** void adjust(void) {
 345:proj3.c       **** 	stop();
 346:proj3.c       **** 	delayMs(5000);
 347:proj3.c       **** 	byteTx(CmdSensors);  // Sensor opcode 
 348:proj3.c       **** 	byteTx(34);   // Send request for packet 0 
 349:proj3.c       **** 	for(uint8_t i = 0; i < Sen6Size; i++) // Read each sensor byte
 350:proj3.c       **** 		sensors[i] = byteRx();
 351:proj3.c       **** 	if(sensors[SenChAvailable]==0 || sensors[SenChargeState]!=0) {
 352:proj3.c       **** 	rotate(180);
 353:proj3.c       **** 	driveStraightDistanceCm(80);
 354:proj3.c       **** 	rotate(180);
 355:proj3.c       **** 	//dock();
 356:proj3.c       **** 	}
 357:proj3.c       **** 	else {
 358:proj3.c       **** 	}
 359:proj3.c       **** }*/
 360:proj3.c       **** 
 361:proj3.c       **** 	void driveStraightDistanceCm(int distance){
 487               		.loc 1 361 0
 488               		.cfi_startproc
 489               	.LVL64:
 490 01fc CF93      		push r28
 491               	.LCFI7:
 492               		.cfi_def_cfa_offset 3
 493               		.cfi_offset 28, -2
 494 01fe DF93      		push r29
 495               	.LCFI8:
 496               		.cfi_def_cfa_offset 4
 497               		.cfi_offset 29, -3
 498               	/* prologue: function */
 499               	/* frame size = 0 */
 500               	/* stack size = 2 */
 501               	.L__stack_usage = 2
 502 0200 EC01      		movw r28,r24
 503               	.LVL65:
 362:proj3.c       **** 		uint8_t driveDelay= distance / 30 *1350;// 30 for 30 cm/s -- 1000 for conversion -- 350 for adjus
 363:proj3.c       **** 		byteTx(CmdDriveWheels);
 504               		.loc 1 363 0
 505 0202 81E9      		ldi r24,lo8(-111)
 506               	.LVL66:
 507 0204 0E94 0000 		call byteTx
 508               	.LVL67:
 364:proj3.c       **** 		byteTx(0x01);//velocity right wheel 300mm/s
 509               		.loc 1 364 0
 510 0208 81E0      		ldi r24,lo8(1)
 511 020a 0E94 0000 		call byteTx
 512               	.LVL68:
 365:proj3.c       **** 		byteTx(0x2c);
 513               		.loc 1 365 0
 514 020e 8CE2      		ldi r24,lo8(44)
 515 0210 0E94 0000 		call byteTx
 516               	.LVL69:
 366:proj3.c       **** 		byteTx(0x01);//velocity left wheel 300mm/s
 517               		.loc 1 366 0
 518 0214 81E0      		ldi r24,lo8(1)
 519 0216 0E94 0000 		call byteTx
 520               	.LVL70:
 367:proj3.c       **** 		byteTx(0x2c);
 521               		.loc 1 367 0
 522 021a 8CE2      		ldi r24,lo8(44)
 523 021c 0E94 0000 		call byteTx
 524               	.LVL71:
 362:proj3.c       **** 		uint8_t driveDelay= distance / 30 *1350;// 30 for 30 cm/s -- 1000 for conversion -- 350 for adjus
 525               		.loc 1 362 0
 526 0220 CE01      		movw r24,r28
 527 0222 6EE1      		ldi r22,lo8(30)
 528 0224 70E0      		ldi r23,0
 529 0226 0E94 0000 		call __divmodhi4
 530 022a 86E4      		ldi r24,lo8(70)
 531 022c 689F      		mul r22,r24
 532 022e 802D      		mov r24,r0
 533 0230 1124      		clr r1
 368:proj3.c       **** 		delayMs(driveDelay);
 534               		.loc 1 368 0
 535 0232 90E0      		ldi r25,0
 536 0234 0E94 0000 		call delayMs
 537               	.LVL72:
 369:proj3.c       **** 		stop();
 538               		.loc 1 369 0
 539 0238 0E94 0000 		call stop
 540               	.LVL73:
 370:proj3.c       **** 		delayMs(15);
 541               		.loc 1 370 0
 542 023c 8FE0      		ldi r24,lo8(15)
 543 023e 90E0      		ldi r25,0
 544               	/* epilogue start */
 371:proj3.c       **** 	}
 545               		.loc 1 371 0
 546 0240 DF91      		pop r29
 547 0242 CF91      		pop r28
 548               	.LVL74:
 370:proj3.c       **** 		delayMs(15);
 549               		.loc 1 370 0
 550 0244 0C94 0000 		jmp delayMs
 551               	.LVL75:
 552               		.cfi_endproc
 553               	.LFE12:
 555               	.global	updateSensors
 557               	updateSensors:
 558               	.LFB13:
 372:proj3.c       **** void updateSensors(void){
 559               		.loc 1 372 0
 560               		.cfi_startproc
 561 0248 EF92      		push r14
 562               	.LCFI9:
 563               		.cfi_def_cfa_offset 3
 564               		.cfi_offset 14, -2
 565 024a FF92      		push r15
 566               	.LCFI10:
 567               		.cfi_def_cfa_offset 4
 568               		.cfi_offset 15, -3
 569 024c 0F93      		push r16
 570               	.LCFI11:
 571               		.cfi_def_cfa_offset 5
 572               		.cfi_offset 16, -4
 573 024e 1F93      		push r17
 574               	.LCFI12:
 575               		.cfi_def_cfa_offset 6
 576               		.cfi_offset 17, -5
 577 0250 CF93      		push r28
 578               	.LCFI13:
 579               		.cfi_def_cfa_offset 7
 580               		.cfi_offset 28, -6
 581 0252 DF93      		push r29
 582               	.LCFI14:
 583               		.cfi_def_cfa_offset 8
 584               		.cfi_offset 29, -7
 585               	/* prologue: function */
 586               	/* frame size = 0 */
 587               	/* stack size = 6 */
 588               	.L__stack_usage = 6
 373:proj3.c       **** if(canSense==1){ // Using timer 0 to continuously update the sensor array
 589               		.loc 1 373 0
 590 0254 8091 0000 		lds r24,canSense
 591 0258 8130      		cpi r24,lo8(1)
 592 025a 01F0      		breq .+2
 593 025c 00C0      		rjmp .L20
 594               	.L22:
 595               	.LBB20:
 596               	.LBB21:
 374:proj3.c       **** 	uint8_t i;
 375:proj3.c       **** 	while(UCSR0A & 0x80)
 597               		.loc 1 375 0
 598 025e 8091 C000 		lds r24,192
 599 0262 87FF      		sbrs r24,7
 600 0264 00C0      		rjmp .L76
 376:proj3.c       **** 	i = UDR0;
 601               		.loc 1 376 0
 602 0266 8091 C600 		lds r24,198
 603 026a 00C0      		rjmp .L22
 604               	.L76:
 377:proj3.c       **** 	byteTx(CmdSensors);  // Sensor opcode 
 605               		.loc 1 377 0
 606 026c 8EE8      		ldi r24,lo8(-114)
 607 026e 0E94 0000 		call byteTx
 608               	.LVL76:
 378:proj3.c       **** 	byteTx(6);   // Send request for packet 0 
 609               		.loc 1 378 0
 610 0272 86E0      		ldi r24,lo8(6)
 611 0274 0E94 0000 		call byteTx
 612               	.LVL77:
 613 0278 C0E0      		ldi r28,lo8(sensors)
 614 027a D0E0      		ldi r29,hi8(sensors)
 615               	.LVL78:
 616               	.L25:
 617               	.LBB22:
 379:proj3.c       **** 	for(uint8_t i = 0; i < Sen6Size; i++) // Read each sensor byte
 380:proj3.c       **** 		sensors[i] = byteRx();
 618               		.loc 1 380 0
 619 027c 0E94 0000 		call byteRx
 620               	.LVL79:
 621 0280 8993      		st Y+,r24
 622               	.LVL80:
 379:proj3.c       **** 	for(uint8_t i = 0; i < Sen6Size; i++) // Read each sensor byte
 623               		.loc 1 379 0
 624 0282 50E0      		ldi r21,hi8(sensors+52)
 625 0284 C030      		cpi r28,lo8(sensors+52)
 626 0286 D507      		cpc r29,r21
 627 0288 01F4      		brne .L25
 628               	.LBE22:
 629               	.LBB23:
 381:proj3.c       **** 	for (int i=0;i<9;i++) 
 382:proj3.c       **** 		state=sensors[SenWallSig1] << 8 | sensors[SenWallSig0];//[i]
 630               		.loc 1 382 0
 631 028a 2091 0000 		lds r18,sensors+26
 632 028e 30E0      		ldi r19,0
 633 0290 322F      		mov r19,r18
 634 0292 2227      		clr r18
 635 0294 8091 0000 		lds r24,sensors+27
 636 0298 282B      		or r18,r24
 637               	.LVL81:
 638 029a 3093 0000 		sts state+1,r19
 639 029e 2093 0000 		sts state,r18
 640               	.LBE23:
 383:proj3.c       **** 
 384:proj3.c       **** 	//uint8_t force= (sensors[SenIRChar]==242);
 385:proj3.c       **** 	red= (sensors[SenIRChar]==248);
 641               		.loc 1 385 0
 642 02a2 8091 0000 		lds r24,sensors+10
 643 02a6 91E0      		ldi r25,lo8(1)
 644 02a8 883F      		cpi r24,lo8(-8)
 645 02aa 01F0      		breq .L26
 646 02ac 90E0      		ldi r25,0
 647               	.L26:
 648 02ae 9093 0000 		sts red,r25
 386:proj3.c       **** 	green= (sensors[SenIRChar]==244);
 649               		.loc 1 386 0
 650 02b2 91E0      		ldi r25,lo8(1)
 651 02b4 843F      		cpi r24,lo8(-12)
 652 02b6 01F0      		breq .L27
 653 02b8 90E0      		ldi r25,0
 654               	.L27:
 655 02ba 9093 0000 		sts green,r25
 387:proj3.c       **** 	redgreen= (sensors[SenIRChar]==252);
 656               		.loc 1 387 0
 657 02be 91E0      		ldi r25,lo8(1)
 658 02c0 8C3F      		cpi r24,lo8(-4)
 659 02c2 01F0      		breq .L28
 660 02c4 90E0      		ldi r25,0
 661               	.L28:
 662 02c6 9093 0000 		sts redgreen,r25
 388:proj3.c       **** 	redgreenforce= (sensors[SenIRChar]==254);
 663               		.loc 1 388 0
 664 02ca 91E0      		ldi r25,lo8(1)
 665 02cc 8E3F      		cpi r24,lo8(-2)
 666 02ce 01F0      		breq .L29
 667 02d0 90E0      		ldi r25,0
 668               	.L29:
 669 02d2 9093 0000 		sts redgreenforce,r25
 389:proj3.c       **** 	greenforce= (sensors[SenIRChar]==246);
 670               		.loc 1 389 0
 671 02d6 91E0      		ldi r25,lo8(1)
 672 02d8 863F      		cpi r24,lo8(-10)
 673 02da 01F0      		breq .L30
 674 02dc 90E0      		ldi r25,0
 675               	.L30:
 676 02de 9093 0000 		sts greenforce,r25
 390:proj3.c       **** 	redforce= (sensors[SenIRChar]==250);
 677               		.loc 1 390 0
 678 02e2 91E0      		ldi r25,lo8(1)
 679 02e4 8A3F      		cpi r24,lo8(-6)
 680 02e6 01F0      		breq .L31
 681 02e8 90E0      		ldi r25,0
 682               	.L31:
 683 02ea 9093 0000 		sts redforce,r25
 391:proj3.c       **** 	goodIR= (red||green||redgreen||redgreenforce||greenforce||redforce);
 684               		.loc 1 391 0
 685 02ee 482F      		mov r20,r24
 686 02f0 4D7F      		andi r20,lo8(-3)
 687 02f2 483F      		cpi r20,lo8(-8)
 688 02f4 01F4      		brne .L32
 689               	.L34:
 690 02f6 41E0      		ldi r20,lo8(1)
 691 02f8 00C0      		rjmp .L33
 692               	.L32:
 693 02fa 482F      		mov r20,r24
 694 02fc 457F      		andi r20,lo8(-11)
 695 02fe 443F      		cpi r20,lo8(-12)
 696 0300 01F0      		breq .L34
 697 0302 40E0      		ldi r20,0
 698               	.L33:
 699 0304 4093 0000 		sts goodIR,r20
 392:proj3.c       **** 	anyforce= (redgreenforce||greenforce||redforce);
 700               		.loc 1 392 0
 701 0308 877F      		andi r24,lo8(-9)
 702 030a 863F      		cpi r24,lo8(-10)
 703 030c 01F4      		brne .L35
 704 030e 91E0      		ldi r25,lo8(1)
 705               	.L35:
 706 0310 9093 0000 		sts anyforce,r25
 393:proj3.c       **** /*
 394:proj3.c       **** 	Force Field = 1.5
 395:proj3.c       **** 	Green = 1.0
 396:proj3.c       **** 	Green + Force Field = 2.5
 397:proj3.c       **** 	Red = 1.0
 398:proj3.c       **** 	Red + Force Field = 1.5 
 399:proj3.c       **** 	Red + Green = 2.0
 400:proj3.c       **** 	Red + Green + Force Field = 3.0
 401:proj3.c       **** */
 402:proj3.c       **** 	if(sensors[SenChAvailable]!=0)
 707               		.loc 1 402 0
 708 0314 8091 0000 		lds r24,sensors+39
 709 0318 8823      		tst r24
 710 031a 01F0      		breq .L36
 711               	.L75:
 403:proj3.c       **** 		while(1)stop();
 712               		.loc 1 403 0
 713 031c 0E94 0000 		call stop
 714               	.LVL82:
 715 0320 00C0      		rjmp .L75
 716               	.L36:
 404:proj3.c       **** 	
 405:proj3.c       **** 
 406:proj3.c       **** 	//populate array with whatever we have
 407:proj3.c       **** 	if(populateArray==0) {
 717               		.loc 1 407 0
 718 0322 8091 0000 		lds r24,populateArray
 719 0326 8111      		cpse r24,__zero_reg__
 720 0328 00C0      		rjmp .L38
 721               	.LBB24:
 408:proj3.c       **** 		for(int i=0;i<9;i++) 
 409:proj3.c       **** 			e[i]=SETPOINT-state;
 722               		.loc 1 409 0
 723 032a 8091 0000 		lds r24,SETPOINT
 724 032e 821B      		sub r24,r18
 725 0330 E0E0      		ldi r30,lo8(e)
 726 0332 F0E0      		ldi r31,hi8(e)
 727               	.L40:
 728               	.LVL83:
 729 0334 8193      		st Z+,r24
 730               	.LVL84:
 408:proj3.c       **** 		for(int i=0;i<9;i++) 
 731               		.loc 1 408 0
 732 0336 70E0      		ldi r23,hi8(e+9)
 733 0338 E030      		cpi r30,lo8(e+9)
 734 033a F707      		cpc r31,r23
 735 033c 01F4      		brne .L40
 736               	.LBE24:
 410:proj3.c       **** 		populateArray=1;
 737               		.loc 1 410 0
 738 033e 81E0      		ldi r24,lo8(1)
 739 0340 8093 0000 		sts populateArray,r24
 740               	.LVL85:
 741               	.L38:
 742 0344 C0E0      		ldi r28,0
 743 0346 D0E0      		ldi r29,0
 744               	.LVL86:
 745 0348 E0E0      		ldi r30,lo8(e+1)
 746 034a F0E0      		ldi r31,hi8(e+1)
 747 034c 00E0      		ldi r16,lo8(e)
 748 034e 10E0      		ldi r17,hi8(e)
 749 0350 60E0      		ldi r22,lo8(s+1)
 750 0352 70E0      		ldi r23,hi8(s+1)
 751 0354 80E0      		ldi r24,lo8(s)
 752 0356 E82E      		mov r14,r24
 753 0358 80E0      		ldi r24,hi8(s)
 754 035a F82E      		mov r15,r24
 411:proj3.c       **** 	}
 412:proj3.c       **** 
 413:proj3.c       **** 	///new loop
 414:proj3.c       **** 	sum=0;
 415:proj3.c       **** 	stateSum=0;
 755               		.loc 1 415 0
 756 035c 80E0      		ldi r24,0
 757 035e 90E0      		ldi r25,0
 758               	.LVL87:
 759               	.L42:
 760               	.LBB25:
 416:proj3.c       **** 
 417:proj3.c       **** 	//dump index 0~~bump values down
 418:proj3.c       **** 	for(int j=0;j<8;j++){
 419:proj3.c       **** 		e[j]=e[j+1];
 761               		.loc 1 419 0
 762 0360 5191      		ld r21,Z+
 763               	.LVL88:
 764 0362 D801      		movw r26,r16
 765 0364 5D93      		st X+,r21
 766 0366 8D01      		movw r16,r26
 420:proj3.c       **** 		sum=sum+e[j];
 767               		.loc 1 420 0
 768 0368 C50F      		add r28,r21
 769 036a D11D      		adc r29,__zero_reg__
 421:proj3.c       **** 		s[j]=s[j+1];
 770               		.loc 1 421 0
 771 036c DB01      		movw r26,r22
 772 036e 5D91      		ld r21,X+
 773 0370 BD01      		movw r22,r26
 774 0372 D701      		movw r26,r14
 775 0374 5D93      		st X+,r21
 776 0376 7D01      		movw r14,r26
 422:proj3.c       **** 		stateSum=stateSum+s[j];
 777               		.loc 1 422 0
 778 0378 850F      		add r24,r21
 779 037a 911D      		adc r25,__zero_reg__
 780               	.LVL89:
 418:proj3.c       **** 	for(int j=0;j<8;j++){
 781               		.loc 1 418 0
 782 037c B0E0      		ldi r27,hi8(e+9)
 783 037e E030      		cpi r30,lo8(e+9)
 784 0380 FB07      		cpc r31,r27
 785 0382 01F4      		brne .L42
 786               	.LBE25:
 423:proj3.c       **** 	}
 424:proj3.c       **** 
 425:proj3.c       **** 	//finish state avg
 426:proj3.c       **** 	s[9]=state;
 787               		.loc 1 426 0
 788 0384 2093 0000 		sts s+9,r18
 427:proj3.c       **** 	stateSum=stateSum+s[9];
 789               		.loc 1 427 0
 790 0388 820F      		add r24,r18
 791 038a 911D      		adc r25,__zero_reg__
 792 038c 9093 0000 		sts stateSum+1,r25
 793 0390 8093 0000 		sts stateSum,r24
 428:proj3.c       **** 	avgState=stateSum/10;
 794               		.loc 1 428 0
 795 0394 6AE0      		ldi r22,lo8(10)
 796 0396 70E0      		ldi r23,0
 797 0398 0E94 0000 		call __udivmodhi4
 798 039c 7093 0000 		sts avgState+1,r23
 799 03a0 6093 0000 		sts avgState,r22
 429:proj3.c       **** 
 430:proj3.c       **** 	//finish i summation
 431:proj3.c       **** 	e[9]=SETPOINT-state;
 800               		.loc 1 431 0
 801 03a4 5091 0000 		lds r21,SETPOINT
 802 03a8 521B      		sub r21,r18
 803 03aa 5093 0000 		sts e+9,r21
 432:proj3.c       **** 	sum=sum+e[9];
 804               		.loc 1 432 0
 805 03ae 852F      		mov r24,r21
 806 03b0 90E0      		ldi r25,0
 807 03b2 C80F      		add r28,r24
 808 03b4 D91F      		adc r29,r25
 809 03b6 D093 0000 		sts sum+1,r29
 810 03ba C093 0000 		sts sum,r28
 433:proj3.c       **** 
 434:proj3.c       **** 	//use the array to complete the formula
 435:proj3.c       **** 	P=PGain*e[9];
 811               		.loc 1 435 0
 812 03be E091 0000 		lds r30,PGain
 813               	.LVL90:
 814 03c2 5E9F      		mul r21,r30
 815 03c4 E02D      		mov r30,r0
 816 03c6 1124      		clr r1
 817 03c8 E093 0000 		sts P,r30
 436:proj3.c       **** 	I=IGain*sum*T;
 818               		.loc 1 436 0
 819 03cc 6091 0000 		lds r22,T
 820 03d0 5091 0000 		lds r21,IGain
 821 03d4 659F      		mul r22,r21
 822 03d6 502D      		mov r21,r0
 823 03d8 1124      		clr r1
 824 03da 5C9F      		mul r21,r28
 825 03dc C02D      		mov r28,r0
 826 03de 1124      		clr r1
 827 03e0 C093 0000 		sts I,r28
 437:proj3.c       **** 	D=DGain*((e[9]-e[8])/T);
 828               		.loc 1 437 0
 829 03e4 5091 0000 		lds r21,e+8
 830 03e8 851B      		sub r24,r21
 831 03ea 9109      		sbc r25,__zero_reg__
 832 03ec 70E0      		ldi r23,0
 833 03ee 0E94 0000 		call __divmodhi4
 834 03f2 8091 0000 		lds r24,DGain
 835 03f6 869F      		mul r24,r22
 836 03f8 602D      		mov r22,r0
 837 03fa 1124      		clr r1
 838 03fc 6093 0000 		sts D,r22
 438:proj3.c       **** 	U=(P+I+D)/PROPORTIONAL4U;
 839               		.loc 1 438 0
 840 0400 8C2F      		mov r24,r28
 841 0402 90E0      		ldi r25,0
 842 0404 8E0F      		add r24,r30
 843 0406 911D      		adc r25,__zero_reg__
 844 0408 860F      		add r24,r22
 845 040a 911D      		adc r25,__zero_reg__
 846 040c 6091 0000 		lds r22,PROPORTIONAL4U
 847 0410 70E0      		ldi r23,0
 848 0412 0E94 0000 		call __divmodhi4
 849 0416 6093 0000 		sts U,r22
 850 041a 8091 0000 		lds r24,sensors
 439:proj3.c       **** 
 440:proj3.c       **** 	// Robot states
 441:proj3.c       **** 	// If wall reading and no bumper, then robot should align/follow wall
 442:proj3.c       **** 
 443:proj3.c       **** 	if (state>=6 && sensors[SenBumpDrop]==0){ //ADDED LINE TO SENSE BUMPER WHILE FOLLOWING WALL
 851               		.loc 1 443 0
 852 041e 2630      		cpi r18,6
 853 0420 3105      		cpc r19,__zero_reg__
 854 0422 00F0      		brlo .L43
 855 0424 8111      		cpse r24,__zero_reg__
 856 0426 00C0      		rjmp .L43
 444:proj3.c       **** 		robotState=2; // Aligned with wall (follow)
 857               		.loc 1 444 0
 858 0428 82E0      		ldi r24,lo8(2)
 859 042a 8093 0000 		sts robotState,r24
 445:proj3.c       **** 		startIR=true;				
 860               		.loc 1 445 0
 861 042e 81E0      		ldi r24,lo8(1)
 862 0430 8093 0000 		sts startIR,r24
 863 0434 00C0      		rjmp .L44
 864               	.L43:
 446:proj3.c       **** 	}
 447:proj3.c       **** 	// If no wall reading and no bumper, robot should look for a wall
 448:proj3.c       **** 	else if (sensors[SenBumpDrop]==0 && state<=5) 
 865               		.loc 1 448 0
 866 0436 8111      		cpse r24,__zero_reg__
 867 0438 00C0      		rjmp .L45
 868 043a 2630      		cpi r18,6
 869 043c 3105      		cpc r19,__zero_reg__
 870 043e 00F4      		brsh .L45
 449:proj3.c       **** 		robotState=0; // No wall (drive straight)//NO DRIVE TO THE LEFT MORE SLOWER-E
 871               		.loc 1 449 0
 872 0440 1092 0000 		sts robotState,__zero_reg__
 873 0444 00C0      		rjmp .L44
 874               	.L45:
 450:proj3.c       **** 	// Otherwise, robot is against the wall and needs to rotate to keep moving
 451:proj3.c       **** 	else
 452:proj3.c       **** 		robotState=1; // Found wall (rotate)
 875               		.loc 1 452 0
 876 0446 81E0      		ldi r24,lo8(1)
 877 0448 8093 0000 		sts robotState,r24
 878               	.L44:
 453:proj3.c       **** 
 454:proj3.c       **** 	if (goodIR&&startIR){
 879               		.loc 1 454 0
 880 044c 4423      		tst r20
 881 044e 01F0      		breq .L46
 882 0450 8091 0000 		lds r24,startIR
 883 0454 8823      		tst r24
 884 0456 01F0      		breq .L46
 455:proj3.c       **** 		robotState=3; // Docking station signal detected and wallfollowed
 885               		.loc 1 455 0
 886 0458 83E0      		ldi r24,lo8(3)
 887 045a 8093 0000 		sts robotState,r24
 888               	.L46:
 456:proj3.c       **** 	}
 457:proj3.c       **** 
 458:proj3.c       **** 
 459:proj3.c       **** 
 460:proj3.c       **** 
 461:proj3.c       **** 	senseTimerCount=100;
 889               		.loc 1 461 0
 890 045e 84E6      		ldi r24,lo8(100)
 891 0460 90E0      		ldi r25,0
 892 0462 9093 0000 		sts senseTimerCount+1,r25
 893 0466 8093 0000 		sts senseTimerCount,r24
 462:proj3.c       **** 	canSense=0;
 894               		.loc 1 462 0
 895 046a 1092 0000 		sts canSense,__zero_reg__
 896               	.LVL91:
 897               	.L20:
 898               	/* epilogue start */
 899               	.LBE21:
 900               	.LBE20:
 463:proj3.c       **** }//end if (canSense)
 464:proj3.c       **** 
 465:proj3.c       **** }
 901               		.loc 1 465 0
 902 046e DF91      		pop r29
 903 0470 CF91      		pop r28
 904 0472 1F91      		pop r17
 905 0474 0F91      		pop r16
 906 0476 FF90      		pop r15
 907 0478 EF90      		pop r14
 908 047a 0895      		ret
 909               		.cfi_endproc
 910               	.LFE13:
 912               	.global	dock
 914               	dock:
 915               	.LFB10:
 249:proj3.c       **** void dock(void) {
 916               		.loc 1 249 0
 917               		.cfi_startproc
 918               	/* prologue: function */
 919               	/* frame size = 0 */
 920               	/* stack size = 0 */
 921               	.L__stack_usage = 0
 278:proj3.c       **** if(first){
 922               		.loc 1 278 0
 923 047c 8091 0000 		lds r24,first
 924 0480 8823      		tst r24
 925 0482 01F0      		breq .L79
 279:proj3.c       **** 	rotate(90, left);
 926               		.loc 1 279 0
 927 0484 6091 0000 		lds r22,left
 928 0488 8AE5      		ldi r24,lo8(90)
 929 048a 0E94 0000 		call rotate
 930               	.LVL92:
 280:proj3.c       **** 	first=false;
 931               		.loc 1 280 0
 932 048e 1092 0000 		sts first,__zero_reg__
 933               	.L80:
 281:proj3.c       **** 	while(sensors[SenBumpDrop]!=0){
 934               		.loc 1 281 0 discriminator 1
 935 0492 8091 0000 		lds r24,sensors
 936 0496 8823      		tst r24
 937 0498 01F0      		breq .L79
 282:proj3.c       **** 		rotate(5,left);
 938               		.loc 1 282 0
 939 049a 6091 0000 		lds r22,left
 940 049e 85E0      		ldi r24,lo8(5)
 941 04a0 0E94 0000 		call rotate
 942               	.LVL93:
 283:proj3.c       **** 		updateSensors();		
 943               		.loc 1 283 0
 944 04a4 0E94 0000 		call updateSensors
 945               	.LVL94:
 946 04a8 00C0      		rjmp .L80
 947               	.L92:
 291:proj3.c       **** 	byteTx(CmdSafe);
 948               		.loc 1 291 0
 949 04aa 83E8      		ldi r24,lo8(-125)
 950 04ac 0E94 0000 		call byteTx
 951               	.LVL95:
 292:proj3.c       **** 	stop();
 952               		.loc 1 292 0
 953 04b0 0E94 0000 		call stop
 954               	.LVL96:
 293:proj3.c       **** 	delayMs(5000);
 955               		.loc 1 293 0
 956 04b4 88E8      		ldi r24,lo8(-120)
 957 04b6 93E1      		ldi r25,lo8(19)
 958 04b8 0E94 0000 		call delayMs
 959               	.LVL97:
 294:proj3.c       **** 	updateSensors();
 960               		.loc 1 294 0
 961 04bc 0E94 0000 		call updateSensors
 962               	.LVL98:
 296:proj3.c       **** 	if(sensors[SenBumpDrop]!=0){
 963               		.loc 1 296 0
 964 04c0 8091 0000 		lds r24,sensors
 965 04c4 8111      		cpse r24,__zero_reg__
 297:proj3.c       **** 		reverse();
 966               		.loc 1 297 0
 967 04c6 0E94 0000 		call reverse
 968               	.LVL99:
 969               	.L79:
 287:proj3.c       **** updateSensors();
 970               		.loc 1 287 0
 971 04ca 0E94 0000 		call updateSensors
 972               	.LVL100:
 289:proj3.c       **** if(sensors[SenBumpDrop]!=0){
 973               		.loc 1 289 0
 974 04ce 8091 0000 		lds r24,sensors
 975 04d2 8111      		cpse r24,__zero_reg__
 976 04d4 00C0      		rjmp .L92
 300:proj3.c       **** else if(red||redforce)//red
 977               		.loc 1 300 0
 978 04d6 8091 0000 		lds r24,red
 979 04da 8111      		cpse r24,__zero_reg__
 980 04dc 00C0      		rjmp .L87
 300:proj3.c       **** else if(red||redforce)//red
 981               		.loc 1 300 0 is_stmt 0 discriminator 1
 982 04de 8091 0000 		lds r24,redforce
 983 04e2 8823      		tst r24
 984 04e4 01F0      		breq .L88
 985               	.L87:
 301:proj3.c       **** 	faceHome(right);
 986               		.loc 1 301 0 is_stmt 1
 987 04e6 8091 0000 		lds r24,right
 988 04ea 00C0      		rjmp .L91
 989               	.L88:
 302:proj3.c       **** else if(green||greenforce)//green
 990               		.loc 1 302 0
 991 04ec 8091 0000 		lds r24,green
 992 04f0 8111      		cpse r24,__zero_reg__
 993 04f2 00C0      		rjmp .L89
 302:proj3.c       **** else if(green||greenforce)//green
 994               		.loc 1 302 0 is_stmt 0 discriminator 1
 995 04f4 8091 0000 		lds r24,greenforce
 996 04f8 8823      		tst r24
 997 04fa 01F0      		breq .L90
 998               	.L89:
 303:proj3.c       **** 	faceHome(left);
 999               		.loc 1 303 0 is_stmt 1
 1000 04fc 8091 0000 		lds r24,left
 1001               	.L91:
 1002 0500 0E94 0000 		call faceHome
 1003               	.LVL101:
 1004 0504 00C0      		rjmp .L79
 1005               	.L90:
 305:proj3.c       **** 	driveStraightHome();
 1006               		.loc 1 305 0
 1007 0506 0E94 0000 		call driveStraightHome
 1008               	.LVL102:
 1009 050a 00C0      		rjmp .L79
 1010               		.cfi_endproc
 1011               	.LFE10:
 1013               		.section	.text.startup,"ax",@progbits
 1014               	.global	main
 1016               	main:
 1017               	.LFB1:
  83:proj3.c       **** int main(void) {
 1018               		.loc 1 83 0
 1019               		.cfi_startproc
 1020               	/* prologue: function */
 1021               	/* frame size = 0 */
 1022               	/* stack size = 0 */
 1023               	.L__stack_usage = 0
  85:proj3.c       **** initializeCommandModule();
 1024               		.loc 1 85 0
 1025 0000 0E94 0000 		call initializeCommandModule
 1026               	.LVL103:
  87:proj3.c       **** powerOnRobot();
 1027               		.loc 1 87 0
 1028 0004 0E94 0000 		call powerOnRobot
 1029               	.LVL104:
  89:proj3.c       **** byteTx(CmdStart);
 1030               		.loc 1 89 0
 1031 0008 80E8      		ldi r24,lo8(-128)
 1032 000a 0E94 0000 		call byteTx
 1033               	.LVL105:
  91:proj3.c       **** baud(Baud57600);
 1034               		.loc 1 91 0
 1035 000e 8AE0      		ldi r24,lo8(10)
 1036 0010 0E94 0000 		call baud
 1037               	.LVL106:
  93:proj3.c       **** defineSongs();
 1038               		.loc 1 93 0
 1039 0014 0E94 0000 		call defineSongs
 1040               	.LVL107:
  95:proj3.c       **** byteTx(CmdControl);
 1041               		.loc 1 95 0
 1042 0018 82E8      		ldi r24,lo8(-126)
 1043 001a 0E94 0000 		call byteTx
 1044               	.LVL108:
  98:proj3.c       **** byteTx(CmdFull);
 1045               		.loc 1 98 0
 1046 001e 84E8      		ldi r24,lo8(-124)
 1047 0020 0E94 0000 		call byteTx
 1048               	.LVL109:
 105:proj3.c       **** byteTx(CmdPlay);
 1049               		.loc 1 105 0
 1050 0024 8DE8      		ldi r24,lo8(-115)
 1051 0026 0E94 0000 		call byteTx
 1052               	.LVL110:
 106:proj3.c       **** byteTx(RESET_SONG);
 1053               		.loc 1 106 0
 1054 002a 80E0      		ldi r24,0
 1055 002c 0E94 0000 		call byteTx
 1056               	.LVL111:
 107:proj3.c       **** delayMs(750);
 1057               		.loc 1 107 0
 1058 0030 8EEE      		ldi r24,lo8(-18)
 1059 0032 92E0      		ldi r25,lo8(2)
 1060 0034 0E94 0000 		call delayMs
 1061               	.LVL112:
 111:proj3.c       **** byteTx(CmdLeds);
 1062               		.loc 1 111 0
 1063 0038 8BE8      		ldi r24,lo8(-117)
 1064 003a 0E94 0000 		call byteTx
 1065               	.LVL113:
 112:proj3.c       **** byteTx(0x00);
 1066               		.loc 1 112 0
 1067 003e 80E0      		ldi r24,0
 1068 0040 0E94 0000 		call byteTx
 1069               	.LVL114:
 113:proj3.c       **** byteTx(0);
 1070               		.loc 1 113 0
 1071 0044 80E0      		ldi r24,0
 1072 0046 0E94 0000 		call byteTx
 1073               	.LVL115:
 114:proj3.c       **** byteTx(255);
 1074               		.loc 1 114 0
 1075 004a 8FEF      		ldi r24,lo8(-1)
 1076 004c 0E94 0000 		call byteTx
 1077               	.LVL116:
 133:proj3.c       **** 	hasTurned=1;
 1078               		.loc 1 133 0
 1079 0050 C1E0      		ldi r28,lo8(1)
 1080               	.L100:
 118:proj3.c       **** updateSensors();
 1081               		.loc 1 118 0
 1082 0052 0E94 0000 		call updateSensors
 1083               	.LVL117:
 121:proj3.c       **** if(sensors[SenBumpDrop]<=4) {
 1084               		.loc 1 121 0
 1085 0056 8091 0000 		lds r24,sensors
 1086 005a 8530      		cpi r24,lo8(5)
 1087 005c 00F4      		brsh .L94
 122:proj3.c       **** 	if(robotState==3)
 1088               		.loc 1 122 0
 1089 005e 8091 0000 		lds r24,robotState
 1090 0062 8330      		cpi r24,lo8(3)
 1091 0064 01F4      		brne .L95
 123:proj3.c       **** 		dock();
 1092               		.loc 1 123 0
 1093 0066 0E94 0000 		call dock
 1094               	.LVL118:
 1095               	.L95:
 125:proj3.c       **** 	if (robotState==0)// no wall, drive straight
 1096               		.loc 1 125 0
 1097 006a 8111      		cpse r24,__zero_reg__
 1098 006c 00C0      		rjmp .L96
 126:proj3.c       **** 		driveStraight();
 1099               		.loc 1 126 0
 1100 006e 0E94 0000 		call driveStraight
 1101               	.LVL119:
 1102 0072 00C0      		rjmp .L97
 1103               	.L96:
 127:proj3.c       **** 	else if (robotState==1) { // on wall, stop and rotate
 1104               		.loc 1 127 0
 1105 0074 8130      		cpi r24,lo8(1)
 1106 0076 01F4      		brne .L98
 128:proj3.c       **** 		stop();
 1107               		.loc 1 128 0
 1108 0078 0E94 0000 		call stop
 1109               	.LVL120:
 129:proj3.c       **** 		rotate(5,left);
 1110               		.loc 1 129 0
 1111 007c 6091 0000 		lds r22,left
 1112 0080 85E0      		ldi r24,lo8(5)
 1113 0082 0E94 0000 		call rotate
 1114               	.LVL121:
 1115 0086 00C0      		rjmp .L97
 1116               	.L98:
 131:proj3.c       **** 	else if (robotState==2){
 1117               		.loc 1 131 0
 1118 0088 8230      		cpi r24,lo8(2)
 1119 008a 01F4      		brne .L97
 132:proj3.c       **** 	followWall();
 1120               		.loc 1 132 0
 1121 008c 0E94 0000 		call followWall
 1122               	.LVL122:
 133:proj3.c       **** 	hasTurned=1;
 1123               		.loc 1 133 0
 1124 0090 C093 0000 		sts hasTurned,r28
 1125 0094 00C0      		rjmp .L97
 1126               	.L94:
 138:proj3.c       **** 	stop();
 1127               		.loc 1 138 0
 1128 0096 0E94 0000 		call stop
 1129               	.LVL123:
 1130               	.L97:
 140:proj3.c       **** delayMs(15);
 1131               		.loc 1 140 0
 1132 009a 8FE0      		ldi r24,lo8(15)
 1133 009c 90E0      		ldi r25,0
 1134 009e 0E94 0000 		call delayMs
 1135               	.LVL124:
 141:proj3.c       **** if(UserButtonPressed) {
 1136               		.loc 1 141 0
 1137 00a2 4C99      		sbic 0x9,4
 1138 00a4 00C0      		rjmp .L100
 142:proj3.c       **** 	powerOffRobot();
 1139               		.loc 1 142 0
 1140 00a6 0E94 0000 		call powerOffRobot
 1141               	.LVL125:
 143:proj3.c       **** 	exit(1);
 1142               		.loc 1 143 0
 1143 00aa 81E0      		ldi r24,lo8(1)
 1144 00ac 90E0      		ldi r25,0
 1145 00ae 0E94 0000 		call exit
 1146               	.LVL126:
 1147               		.cfi_endproc
 1148               	.LFE1:
 1150               		.comm	anyforce,1,1
 1151               	.global	first
 1152               		.data
 1155               	first:
 1156 0000 01        		.byte	1
 1157               		.comm	located,1,1
 1158               		.comm	goodIR,1,1
 1159               		.comm	redforce,1,1
 1160               		.comm	greenforce,1,1
 1161               		.comm	redgreenforce,1,1
 1162               		.comm	redgreen,1,1
 1163               		.comm	green,1,1
 1164               		.comm	red,1,1
 1165               		.comm	lowBitLeft,1,1
 1166               		.comm	highBitLeft,1,1
 1167               		.comm	leftSpeed,2,1
 1168               		.comm	lowBit,1,1
 1169               		.comm	highBit,1,1
 1170               		.comm	newSpeed,2,1
 1171               		.comm	wheelSpeed,2,1
 1172               		.comm	s,10,1
 1173               	.global	hasTurned
 1174               		.section .bss
 1177               	hasTurned:
 1178 0000 00        		.zero	1
 1179               		.comm	avgState,2,1
 1180               		.comm	stateSum,2,1
 1181               	.global	slowTheFuckDown
 1184               	slowTheFuckDown:
 1185 0001 00        		.zero	1
 1186               	.global	firstStraight
 1187               		.data
 1190               	firstStraight:
 1191 0001 01        		.byte	1
 1192               	.global	populateArray
 1193               		.section .bss
 1196               	populateArray:
 1197 0002 00        		.zero	1
 1198               		.comm	e,10,1
 1199               		.comm	sum,2,1
 1200               	.global	T
 1201               		.data
 1204               	T:
 1205 0002 01        		.byte	1
 1206               	.global	PROPORTIONAL4U
 1209               	PROPORTIONAL4U:
 1210 0003 64        		.byte	100
 1211               	.global	DGain
 1214               	DGain:
 1215 0004 C8        		.byte	-56
 1216               	.global	IGain
 1219               	IGain:
 1220 0005 14        		.byte	20
 1221               	.global	PGain
 1224               	PGain:
 1225 0006 50        		.byte	80
 1226               		.comm	U,1,1
 1227               		.comm	D,1,1
 1228               		.comm	I,1,1
 1229               		.comm	P,1,1
 1230               	.global	startIR
 1231               		.section .bss
 1234               	startIR:
 1235 0003 00        		.zero	1
 1236               	.global	robotState
 1239               	robotState:
 1240 0004 00        		.zero	1
 1241               	.global	SETPOINT
 1242               		.data
 1245               	SETPOINT:
 1246 0007 50        		.byte	80
 1247               		.comm	state,2,1
 1248               		.comm	sensors,52,1
 1249               	.global	left
 1250               		.section .bss
 1253               	left:
 1254 0005 00        		.zero	1
 1255               	.global	right
 1256               		.data
 1259               	right:
 1260 0008 01        		.byte	1
 1261               		.text
 1262               	.Letext0:
 1263               		.file 2 "/usr/lib/avr/include/stdint.h"
 1264               		.file 3 "timer.h"
 1265               		.file 4 "cmod.h"
 1266               		.file 5 "iroblib.h"
 1267               		.file 6 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 proj3.c
     /tmp/ccP85E8X.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccP85E8X.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccP85E8X.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccP85E8X.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccP85E8X.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccP85E8X.s:12     .text:0000000000000000 stop
     /tmp/ccP85E8X.s:46     .text:000000000000001e rotate
     /tmp/ccP85E8X.s:145    .text:0000000000000080 driveStraightHome
     /tmp/ccP85E8X.s:178    .text:000000000000009e home
     /tmp/ccP85E8X.s:211    .text:00000000000000bc faceHome
     /tmp/ccP85E8X.s:286    .text:00000000000000f8 findWall
                            *COM*:0000000000000034 sensors
     /tmp/ccP85E8X.s:311    .text:000000000000010c driveStraight
                            *COM*:0000000000000002 avgState
     /tmp/ccP85E8X.s:1177   .bss:0000000000000000 hasTurned
     /tmp/ccP85E8X.s:1239   .bss:0000000000000004 robotState
     /tmp/ccP85E8X.s:384    .text:000000000000016e followWall
                            *COM*:0000000000000002 wheelSpeed
                            *COM*:0000000000000001 U
                            *COM*:0000000000000002 leftSpeed
                            *COM*:0000000000000001 highBitLeft
                            *COM*:0000000000000001 lowBitLeft
                            *COM*:0000000000000002 newSpeed
                            *COM*:0000000000000001 highBit
                            *COM*:0000000000000001 lowBit
     /tmp/ccP85E8X.s:444    .text:00000000000001d2 reverse
     /tmp/ccP85E8X.s:485    .text:00000000000001fc driveStraightDistanceCm
     /tmp/ccP85E8X.s:557    .text:0000000000000248 updateSensors
                            *COM*:0000000000000002 state
                            *COM*:0000000000000001 red
                            *COM*:0000000000000001 green
                            *COM*:0000000000000001 redgreen
                            *COM*:0000000000000001 redgreenforce
                            *COM*:0000000000000001 greenforce
                            *COM*:0000000000000001 redforce
                            *COM*:0000000000000001 goodIR
                            *COM*:0000000000000001 anyforce
     /tmp/ccP85E8X.s:1196   .bss:0000000000000002 populateArray
     /tmp/ccP85E8X.s:1245   .data:0000000000000007 SETPOINT
                            *COM*:000000000000000a e
                            *COM*:000000000000000a s
                            *COM*:0000000000000002 stateSum
                            *COM*:0000000000000002 sum
     /tmp/ccP85E8X.s:1224   .data:0000000000000006 PGain
                            *COM*:0000000000000001 P
     /tmp/ccP85E8X.s:1204   .data:0000000000000002 T
     /tmp/ccP85E8X.s:1219   .data:0000000000000005 IGain
                            *COM*:0000000000000001 I
     /tmp/ccP85E8X.s:1214   .data:0000000000000004 DGain
                            *COM*:0000000000000001 D
     /tmp/ccP85E8X.s:1209   .data:0000000000000003 PROPORTIONAL4U
     /tmp/ccP85E8X.s:1234   .bss:0000000000000003 startIR
     /tmp/ccP85E8X.s:914    .text:000000000000047c dock
     /tmp/ccP85E8X.s:1155   .data:0000000000000000 first
     /tmp/ccP85E8X.s:1253   .bss:0000000000000005 left
     /tmp/ccP85E8X.s:1259   .data:0000000000000008 right
     /tmp/ccP85E8X.s:1016   .text.startup:0000000000000000 main
                            *COM*:0000000000000001 located
     /tmp/ccP85E8X.s:1184   .bss:0000000000000001 slowTheFuckDown
     /tmp/ccP85E8X.s:1190   .data:0000000000000001 firstStraight

UNDEFINED SYMBOLS
byteTx
delayMs
__divmodhi4
canSense
byteRx
__udivmodhi4
senseTimerCount
initializeCommandModule
powerOnRobot
baud
defineSongs
powerOffRobot
exit
__do_copy_data
__do_clear_bss

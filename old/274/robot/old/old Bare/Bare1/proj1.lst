   1               		.file	"proj1.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	printBuffer
  12               	printBuffer:
  13               	.LFB14:
  14               		.file 1 "proj1.c"
   1:proj1.c       **** #include "timer.h"
   2:proj1.c       **** #include "cmod.h"
   3:proj1.c       **** #include "iroblib.h"
   4:proj1.c       **** #include "oi.h"
   5:proj1.c       **** #include <stdlib.h>
   6:proj1.c       **** #include <stdio.h>
   7:proj1.c       **** #include <string.h>
   8:proj1.c       **** 
   9:proj1.c       **** // Declare Global variables 
  10:proj1.c       **** uint16_t DELAY; // 1ms delay
  11:proj1.c       **** uint8_t notReadyBool; // play button detection
  12:proj1.c       **** double PI=3.14159265358979323846;
  13:proj1.c       **** int true=1;
  14:proj1.c       **** int false=0;
  15:proj1.c       **** uint8_t sensors[Sen6Size];
  16:proj1.c       **** 
  17:proj1.c       **** // functions
  18:proj1.c       **** int main(void);
  19:proj1.c       **** void printBuffer(char buf[]);
  20:proj1.c       **** 
  21:proj1.c       **** int main(void) {
  22:proj1.c       **** 	// Set up Create and module
  23:proj1.c       **** 	initializeCommandModule();
  24:proj1.c       **** 
  25:proj1.c       **** 	powerOnRobot();
  26:proj1.c       **** 	// Is the Robot on
  27:proj1.c       **** 	byteTx(CmdStart);
  28:proj1.c       **** 	// Start the create
  29:proj1.c       **** 	baud(Baud57600);
  30:proj1.c       **** 	// Set the baud rate for the Create and Command Module
  31:proj1.c       **** 	defineSongs();
  32:proj1.c       **** 	// Define some songs so that we know the robot is on.
  33:proj1.c       **** 	byteTx(CmdControl);
  34:proj1.c       **** 	// Deprecated form of safe mode. I use it because it will
  35:proj1.c       **** 	// turn of all LEDs, so it's essentially a reset.
  36:proj1.c       **** 	byteTx(CmdFull);
  37:proj1.c       **** 	// We are operating in FULL mode.
  38:proj1.c       **** 
  39:proj1.c       **** 	// CSCE 274 students: I would make sure the robot stops. 
  40:proj1.c       **** 	//                    As a precaution for the robot and your grade.
  41:proj1.c       **** 
  42:proj1.c       **** 	// Play the reset song and wait while it plays.
  43:proj1.c       **** 	byteTx(CmdPlay);
  44:proj1.c       **** 	byteTx(RESET_SONG);
  45:proj1.c       **** 	delayMs(750);
  46:proj1.c       **** 
  47:proj1.c       **** 	// Turn the power button on to something. I like red, but here is green.
  48:proj1.c       **** 	// CSCE 274 students: The following should (will) be a function that you write.
  49:proj1.c       **** 	byteTx(CmdLeds);
  50:proj1.c       **** 	byteTx(0x00);
  51:proj1.c       **** 	byteTx(0);
  52:proj1.c       **** 	byteTx(255);
  53:proj1.c       **** 
  54:proj1.c       **** 	// Methods
  55:proj1.c       **** 	void setupLEDs(void) {
  56:proj1.c       **** 		DDRD |= 0X60;
  57:proj1.c       **** 	}
  58:proj1.c       **** 	void rightLEDon(void) {
  59:proj1.c       **** 		PORTD &= ~0x20;
  60:proj1.c       **** 	}
  61:proj1.c       **** 	void rightLEDoff(void) {
  62:proj1.c       **** 		PORTD |= 0x20;
  63:proj1.c       **** 	}
  64:proj1.c       **** 	void leftLEDon(void) {
  65:proj1.c       **** 		PORTD &= ~0x40;
  66:proj1.c       **** 	}
  67:proj1.c       **** 	void leftLEDoff(void) {
  68:proj1.c       **** 		PORTD |= 0x40;
  69:proj1.c       **** 	}
  70:proj1.c       **** 
  71:proj1.c       **** 	// Initialize global variables
  72:proj1.c       **** 	DELAY=1000;
  73:proj1.c       **** 	notReadyBool=1; 
  74:proj1.c       **** 
  75:proj1.c       **** 	// Task 1.1 (LED toggle)
  76:proj1.c       **** 	/*for(uint8_t i=0;i<5;i++) {
  77:proj1.c       **** 	  setupLEDs();      // activate LEDs
  78:proj1.c       **** 	  leftLEDon();      // begin LED toggle
  79:proj1.c       **** 	  delayMs(DELAY);
  80:proj1.c       **** 	  leftLEDoff();
  81:proj1.c       **** 	  delayMs(DELAY);
  82:proj1.c       **** 	  rightLEDon();
  83:proj1.c       **** 	  delayMs(DELAY);
  84:proj1.c       **** 	  rightLEDoff();
  85:proj1.c       **** 	  delayMs(DELAY);   // end LED toggle
  86:proj1.c       **** 	  }*/
  87:proj1.c       **** 
  88:proj1.c       **** 	// Task 1.2, 1.3 (Bumper Sensors)
  89:proj1.c       **** 	void bumpSense(void) {
  90:proj1.c       **** 		uint8_t bumper;
  91:proj1.c       **** 		while(UCSR0A & 0x80);   // clear the receive buffer
  92:proj1.c       **** 		byteTx(142);            // sensor opcode
  93:proj1.c       **** 		byteTx(7);              // send request for packet 7
  94:proj1.c       **** 		bumper = byteRx();      // set bumper to received sensor packet
  95:proj1.c       **** 		if(bumper==1) {         // check for right bumper detection
  96:proj1.c       **** 			rightLEDon();
  97:proj1.c       **** 		}
  98:proj1.c       **** 		else if(bumper==2) {    // check for left bumper detection
  99:proj1.c       **** 			leftLEDon();
 100:proj1.c       **** 		}
 101:proj1.c       **** 		else if(bumper==3) {    // check for both bumpers
 102:proj1.c       **** 			leftLEDon();
 103:proj1.c       **** 			rightLEDon();
 104:proj1.c       **** 		}
 105:proj1.c       **** 		else {
 106:proj1.c       **** 			leftLEDoff();
 107:proj1.c       **** 			rightLEDoff();
 108:proj1.c       **** 		}
 109:proj1.c       **** 	}
 110:proj1.c       **** 
 111:proj1.c       **** 	void rotateDegreeRight(int degree, int right){
 112:proj1.c       **** 		int rotateDelayMs = degree*8;//gives proper degree at 30cm/s
 113:proj1.c       **** 		if(right==1){//if turning right
 114:proj1.c       **** 			byteTx(CmdDriveWheels);
 115:proj1.c       **** 			byteTx(0xfe);//velocity right wheel -300mm/s
 116:proj1.c       **** 			byteTx(0xd4);
 117:proj1.c       **** 			byteTx(0x01);//velocity left wheel 300mm/s
 118:proj1.c       **** 			byteTx(0x2c);
 119:proj1.c       **** 
 120:proj1.c       **** 		}
 121:proj1.c       **** 		else{//if turning left
 122:proj1.c       **** 			byteTx(CmdDriveWheels);
 123:proj1.c       **** 			byteTx(0x01);//velocity right wheel 300mm/s  
 124:proj1.c       **** 			byteTx(0x2c);
 125:proj1.c       **** 			byteTx(0xfe);//velocity left wheel -300mm/s
 126:proj1.c       **** 			byteTx(0xd4);
 127:proj1.c       **** 		}
 128:proj1.c       **** 		//wheels stop either way
 129:proj1.c       **** 		delayMs(rotateDelayMs);
 130:proj1.c       **** 		byteTx(CmdDriveWheels);
 131:proj1.c       **** 		byteTx(0x00);//stop Wheels
 132:proj1.c       **** 		byteTx(0x00);
 133:proj1.c       **** 		byteTx(0x00);
 134:proj1.c       **** 		byteTx(0x00);
 135:proj1.c       **** 
 136:proj1.c       **** 	}
 137:proj1.c       **** 
 138:proj1.c       **** 	void driveStraightDistanceCm(int distance){
 139:proj1.c       **** 		int driveDelay= distance / 30 *1350;// 30 for 30 cm/s -- 1000 for conversion -- 350 for adjustmen
 140:proj1.c       **** 		byteTx(CmdDriveWheels);
 141:proj1.c       **** 		byteTx(0x01);//velocity right wheel 300mm/s
 142:proj1.c       **** 		byteTx(0x2c);
 143:proj1.c       **** 		byteTx(0x01);//velocity left wheel 300mm/s
 144:proj1.c       **** 		byteTx(0x2c);
 145:proj1.c       **** 		delayMs(driveDelay);
 146:proj1.c       **** 		byteTx(CmdDriveWheels);
 147:proj1.c       **** 		byteTx(0x00);//stop Wheels
 148:proj1.c       **** 		byteTx(0x00);
 149:proj1.c       **** 		byteTx(0x00);
 150:proj1.c       **** 		byteTx(0x00);
 151:proj1.c       **** 	}
 152:proj1.c       **** 
 153:proj1.c       **** 	void play(void){
 154:proj1.c       **** 		for(int i=0;i<4;i++){
 155:proj1.c       **** 			driveStraightDistanceCm(80);
 156:proj1.c       **** 			rotateDegreeRight(72, true);//true for turning right
 157:proj1.c       **** 		}
 158:proj1.c       **** 		driveStraightDistanceCm(80);
 159:proj1.c       **** 	}
 160:proj1.c       **** 
 161:proj1.c       **** 
 162:proj1.c       **** 	void advance(void){
 163:proj1.c       **** 		rotateDegreeRight(180, false);//false for turning left
 164:proj1.c       **** 		for(int i=0;i<4;i++){
 165:proj1.c       **** 			driveStraightDistanceCm(80);
 166:proj1.c       **** 			rotateDegreeRight(72, false);//false for turning left
 167:proj1.c       **** 		}
 168:proj1.c       **** 		driveStraightDistanceCm(80);
 169:proj1.c       **** 
 170:proj1.c       **** 	}
 171:proj1.c       **** 
 172:proj1.c       **** 
 173:proj1.c       **** 	// Task 2.1 (Drive)
 174:proj1.c       **** 	void tryPlay(void){
 175:proj1.c       **** 		uint8_t playPressed;
 176:proj1.c       **** 		while(UCSR0A & 0x80);   // clear the receive buffer
 177:proj1.c       **** 		byteTx(142);            // sensor opcode
 178:proj1.c       **** 		byteTx(18);              // send request for packet 18
 179:proj1.c       **** 		playPressed = byteRx();      // set playPressed to received sensor packet
 180:proj1.c       **** 		if (playPressed==1){
 181:proj1.c       **** 			play();
 182:proj1.c       **** 		}
 183:proj1.c       **** 		//else do nothing	
 184:proj1.c       **** 	}
 185:proj1.c       **** 	void tryAdvance(void){
 186:proj1.c       **** 		uint8_t advancePressed;
 187:proj1.c       **** 		while(UCSR0A & 0x80);   // clear the receive buffer
 188:proj1.c       **** 		byteTx(142);            // sensor opcode
 189:proj1.c       **** 		byteTx(18);              // send request for packet 18
 190:proj1.c       **** 		advancePressed = byteRx();      // set advancePressed to received sensor packet
 191:proj1.c       **** 		if (advancePressed==2){
 192:proj1.c       **** 			advance();
 193:proj1.c       **** 		}
 194:proj1.c       **** 		//else do nothing	
 195:proj1.c       **** 	}
 196:proj1.c       **** 
 197:proj1.c       **** 
 198:proj1.c       **** 
 199:proj1.c       **** 
 200:proj1.c       **** 
 201:proj1.c       **** 
 202:proj1.c       **** 
 203:proj1.c       **** 	// Infinite operation loop
 204:proj1.c       **** 	for(;;) {
 205:proj1.c       **** 		if(canSense==1){
 206:proj1.c       **** 			//cli();
 207:proj1.c       **** 			uint8_t i;
 208:proj1.c       **** 		
 209:proj1.c       **** 			// flushRx()
 210:proj1.c       **** 			//while(UCSR0A & 0x80) // clear the receive buffer
 211:proj1.c       **** 			//  i = UDR0;
 212:proj1.c       **** 			
 213:proj1.c       **** 			byteTx(CmdSensors);  // sensor opcode 
 214:proj1.c       **** 			byteTx(6);   // send request for packet 0 
 215:proj1.c       **** 			for(i = 0; i < Sen6Size; i++){
 216:proj1.c       **** 				sensors[i] = byteRx();
 217:proj1.c       **** 			}  //read each sensor byte			
 218:proj1.c       **** 			//sei();	
 219:proj1.c       **** 			senseTimerCount=100;		
 220:proj1.c       **** 			canSense=0;		
 221:proj1.c       **** 		}
 222:proj1.c       **** 
 223:proj1.c       **** 
 224:proj1.c       **** 		if(canPrint == 1) {	
 225:proj1.c       **** 			setSerialDestination(SERIAL_USB);
 226:proj1.c       **** 			cli();
 227:proj1.c       **** 			char buffer[50];			
 228:proj1.c       **** 			sprintf(buffer,"Cliff Left: %u\n", (uint16_t)((sensors[SenCliffLSig1] << 8)| sensors[SenCliffLSi
 229:proj1.c       **** 			printBuffer(buffer);
 230:proj1.c       **** 			sprintf(buffer,"Current: %i\n", (uint16_t)((sensors[SenCurr1] << 8)| sensors[SenCurr0]));
 231:proj1.c       **** 			printBuffer(buffer);
 232:proj1.c       **** 
 233:proj1.c       **** 			sei();			
 234:proj1.c       **** 			setSerialDestination(SERIAL_CREATE);
 235:proj1.c       **** 			canPrint=0;
 236:proj1.c       **** 		}
 237:proj1.c       **** 		delayMs(15);
 238:proj1.c       **** 		if(UserButtonPressed) {
 239:proj1.c       **** 			powerOffRobot();
 240:proj1.c       **** 			exit(1);
 241:proj1.c       **** 		}
 242:proj1.c       **** 	}
 243:proj1.c       **** }
 244:proj1.c       **** 
 245:proj1.c       **** void printBuffer(char buf[]) {
  15               		.loc 1 245 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 EC01      		movw r28,r24
  39               	.LVL1:
 246:proj1.c       **** 	int i;
 247:proj1.c       **** 	for(i = 0; i < strlen(buf); i++) {
  40               		.loc 1 247 0
  41 000a 8C01      		movw r16,r24
  42               	.LVL2:
  43               	.L2:
  44               		.loc 1 247 0 is_stmt 0 discriminator 1
  45 000c FE01      		movw r30,r28
  46               		0:
  47 000e 0190      		ld __tmp_reg__,Z+
  48 0010 0020      		tst __tmp_reg__
  49 0012 01F4      		brne 0b
  50 0014 3197      		sbiw r30,1
  51 0016 EC1B      		sub r30,r28
  52 0018 FD0B      		sbc r31,r29
  53 001a C801      		movw r24,r16
  54 001c 8C1B      		sub r24,r28
  55 001e 9D0B      		sbc r25,r29
  56               	.LVL3:
  57 0020 8E17      		cp r24,r30
  58 0022 9F07      		cpc r25,r31
  59 0024 00F4      		brsh .L5
 248:proj1.c       **** 		byteTx(buf[i]);
  60               		.loc 1 248 0 is_stmt 1 discriminator 2
  61 0026 F801      		movw r30,r16
  62 0028 8191      		ld r24,Z+
  63               	.LVL4:
  64 002a 8F01      		movw r16,r30
  65               	.LVL5:
  66 002c 0E94 0000 		call byteTx
  67               	.LVL6:
  68 0030 00C0      		rjmp .L2
  69               	.LVL7:
  70               	.L5:
  71               	/* epilogue start */
 249:proj1.c       **** 	}
 250:proj1.c       **** }
  72               		.loc 1 250 0
  73 0032 DF91      		pop r29
  74 0034 CF91      		pop r28
  75               	.LVL8:
  76 0036 1F91      		pop r17
  77 0038 0F91      		pop r16
  78 003a 0895      		ret
  79               		.cfi_endproc
  80               	.LFE14:
  82               		.section	.rodata.str1.1,"aMS",@progbits,1
  83               	.LC0:
  84 0000 436C 6966 		.string	"Cliff Left: %u\n"
  84      6620 4C65 
  84      6674 3A20 
  84      2575 0A00 
  85               	.LC1:
  86 0010 4375 7272 		.string	"Current: %i\n"
  86      656E 743A 
  86      2025 690A 
  86      00
  87               		.section	.text.startup,"ax",@progbits
  88               	.global	main
  90               	main:
  91               	.LFB1:
  21:proj1.c       **** int main(void) {
  92               		.loc 1 21 0
  93               		.cfi_startproc
  94 0000 CF93      		push r28
  95               	.LCFI4:
  96               		.cfi_def_cfa_offset 3
  97               		.cfi_offset 28, -2
  98 0002 DF93      		push r29
  99               	.LCFI5:
 100               		.cfi_def_cfa_offset 4
 101               		.cfi_offset 29, -3
 102 0004 CDB7      		in r28,__SP_L__
 103 0006 DEB7      		in r29,__SP_H__
 104               	.LCFI6:
 105               		.cfi_def_cfa_register 28
 106 0008 E297      		sbiw r28,50
 107               	.LCFI7:
 108               		.cfi_def_cfa_offset 54
 109 000a 0FB6      		in __tmp_reg__,__SREG__
 110 000c F894      		cli
 111 000e DEBF      		out __SP_H__,r29
 112 0010 0FBE      		out __SREG__,__tmp_reg__
 113 0012 CDBF      		out __SP_L__,r28
 114               	/* prologue: function */
 115               	/* frame size = 50 */
 116               	/* stack size = 52 */
 117               	.L__stack_usage = 52
  23:proj1.c       **** 	initializeCommandModule();
 118               		.loc 1 23 0
 119 0014 0E94 0000 		call initializeCommandModule
 120               	.LVL9:
  25:proj1.c       **** 	powerOnRobot();
 121               		.loc 1 25 0
 122 0018 0E94 0000 		call powerOnRobot
 123               	.LVL10:
  27:proj1.c       **** 	byteTx(CmdStart);
 124               		.loc 1 27 0
 125 001c 80E8      		ldi r24,lo8(-128)
 126 001e 0E94 0000 		call byteTx
 127               	.LVL11:
  29:proj1.c       **** 	baud(Baud57600);
 128               		.loc 1 29 0
 129 0022 8AE0      		ldi r24,lo8(10)
 130 0024 0E94 0000 		call baud
 131               	.LVL12:
  31:proj1.c       **** 	defineSongs();
 132               		.loc 1 31 0
 133 0028 0E94 0000 		call defineSongs
 134               	.LVL13:
  33:proj1.c       **** 	byteTx(CmdControl);
 135               		.loc 1 33 0
 136 002c 82E8      		ldi r24,lo8(-126)
 137 002e 0E94 0000 		call byteTx
 138               	.LVL14:
  36:proj1.c       **** 	byteTx(CmdFull);
 139               		.loc 1 36 0
 140 0032 84E8      		ldi r24,lo8(-124)
 141 0034 0E94 0000 		call byteTx
 142               	.LVL15:
  43:proj1.c       **** 	byteTx(CmdPlay);
 143               		.loc 1 43 0
 144 0038 8DE8      		ldi r24,lo8(-115)
 145 003a 0E94 0000 		call byteTx
 146               	.LVL16:
  44:proj1.c       **** 	byteTx(RESET_SONG);
 147               		.loc 1 44 0
 148 003e 80E0      		ldi r24,0
 149 0040 0E94 0000 		call byteTx
 150               	.LVL17:
  45:proj1.c       **** 	delayMs(750);
 151               		.loc 1 45 0
 152 0044 8EEE      		ldi r24,lo8(-18)
 153 0046 92E0      		ldi r25,lo8(2)
 154 0048 0E94 0000 		call delayMs
 155               	.LVL18:
  49:proj1.c       **** 	byteTx(CmdLeds);
 156               		.loc 1 49 0
 157 004c 8BE8      		ldi r24,lo8(-117)
 158 004e 0E94 0000 		call byteTx
 159               	.LVL19:
  50:proj1.c       **** 	byteTx(0x00);
 160               		.loc 1 50 0
 161 0052 80E0      		ldi r24,0
 162 0054 0E94 0000 		call byteTx
 163               	.LVL20:
  51:proj1.c       **** 	byteTx(0);
 164               		.loc 1 51 0
 165 0058 80E0      		ldi r24,0
 166 005a 0E94 0000 		call byteTx
 167               	.LVL21:
  52:proj1.c       **** 	byteTx(255);
 168               		.loc 1 52 0
 169 005e 8FEF      		ldi r24,lo8(-1)
 170 0060 0E94 0000 		call byteTx
 171               	.LVL22:
  72:proj1.c       **** 	DELAY=1000;
 172               		.loc 1 72 0
 173 0064 88EE      		ldi r24,lo8(-24)
 174 0066 93E0      		ldi r25,lo8(3)
 175 0068 9093 0000 		sts DELAY+1,r25
 176 006c 8093 0000 		sts DELAY,r24
  73:proj1.c       **** 	notReadyBool=1; 
 177               		.loc 1 73 0
 178 0070 81E0      		ldi r24,lo8(1)
 179 0072 8093 0000 		sts notReadyBool,r24
 180               	.LBB2:
 219:proj1.c       **** 			senseTimerCount=100;		
 181               		.loc 1 219 0
 182 0076 54E6      		ldi r21,lo8(100)
 183 0078 A52E      		mov r10,r21
 184 007a B12C      		mov r11,__zero_reg__
 185               	.LBE2:
 186               	.LBB3:
 228:proj1.c       **** 			sprintf(buffer,"Cliff Left: %u\n", (uint16_t)((sensors[SenCliffLSig1] << 8)| sensors[SenCliffLSi
 187               		.loc 1 228 0
 188 007c 60E0      		ldi r22,lo8(.LC0)
 189 007e E62E      		mov r14,r22
 190 0080 60E0      		ldi r22,hi8(.LC0)
 191 0082 F62E      		mov r15,r22
 192 0084 8E01      		movw r16,r28
 193 0086 0F5F      		subi r16,-1
 194 0088 1F4F      		sbci r17,-1
 230:proj1.c       **** 			sprintf(buffer,"Current: %i\n", (uint16_t)((sensors[SenCurr1] << 8)| sensors[SenCurr0]));
 195               		.loc 1 230 0
 196 008a 70E0      		ldi r23,lo8(.LC1)
 197 008c C72E      		mov r12,r23
 198 008e 70E0      		ldi r23,hi8(.LC1)
 199 0090 D72E      		mov r13,r23
 200               	.L12:
 201               	.LBE3:
 205:proj1.c       **** 		if(canSense==1){
 202               		.loc 1 205 0
 203 0092 8091 0000 		lds r24,canSense
 204 0096 8130      		cpi r24,lo8(1)
 205 0098 01F4      		brne .L7
 206               	.LBB4:
 213:proj1.c       **** 			byteTx(CmdSensors);  // sensor opcode 
 207               		.loc 1 213 0
 208 009a 8EE8      		ldi r24,lo8(-114)
 209 009c 0E94 0000 		call byteTx
 210               	.LVL23:
 214:proj1.c       **** 			byteTx(6);   // send request for packet 0 
 211               		.loc 1 214 0
 212 00a0 86E0      		ldi r24,lo8(6)
 213 00a2 0E94 0000 		call byteTx
 214               	.LVL24:
 215 00a6 40E0      		ldi r20,lo8(sensors)
 216 00a8 842E      		mov r8,r20
 217 00aa 40E0      		ldi r20,hi8(sensors)
 218 00ac 942E      		mov r9,r20
 219               	.LVL25:
 220               	.L9:
 216:proj1.c       **** 				sensors[i] = byteRx();
 221               		.loc 1 216 0 discriminator 2
 222 00ae 0E94 0000 		call byteRx
 223               	.LVL26:
 224 00b2 F401      		movw r30,r8
 225 00b4 8193      		st Z+,r24
 226 00b6 4F01      		movw r8,r30
 227               	.LVL27:
 215:proj1.c       **** 			for(i = 0; i < Sen6Size; i++){
 228               		.loc 1 215 0 discriminator 2
 229 00b8 F0E0      		ldi r31,lo8(sensors+52)
 230 00ba 8F16      		cp r8,r31
 231 00bc F0E0      		ldi r31,hi8(sensors+52)
 232 00be 9F06      		cpc r9,r31
 233 00c0 01F4      		brne .L9
 219:proj1.c       **** 			senseTimerCount=100;		
 234               		.loc 1 219 0
 235 00c2 B092 0000 		sts senseTimerCount+1,r11
 236 00c6 A092 0000 		sts senseTimerCount,r10
 220:proj1.c       **** 			canSense=0;		
 237               		.loc 1 220 0
 238 00ca 1092 0000 		sts canSense,__zero_reg__
 239               	.LVL28:
 240               	.L7:
 241               	.LBE4:
 224:proj1.c       **** 		if(canPrint == 1) {	
 242               		.loc 1 224 0
 243 00ce 8091 0000 		lds r24,canPrint
 244 00d2 8130      		cpi r24,lo8(1)
 245 00d4 01F4      		brne .L10
 246               	.LBB5:
 225:proj1.c       **** 			setSerialDestination(SERIAL_USB);
 247               		.loc 1 225 0
 248 00d6 82E0      		ldi r24,lo8(2)
 249 00d8 0E94 0000 		call setSerialDestination
 250               	.LVL29:
 226:proj1.c       **** 			cli();
 251               		.loc 1 226 0
 252               	/* #APP */
 253               	 ;  226 "proj1.c" 1
 254 00dc F894      		cli
 255               	 ;  0 "" 2
 228:proj1.c       **** 			sprintf(buffer,"Cliff Left: %u\n", (uint16_t)((sensors[SenCliffLSig1] << 8)| sensors[SenCliffLSi
 256               		.loc 1 228 0
 257               	/* #NOAPP */
 258 00de 8091 0000 		lds r24,sensors+28
 259 00e2 90E0      		ldi r25,0
 260 00e4 982F      		mov r25,r24
 261 00e6 8827      		clr r24
 262 00e8 2091 0000 		lds r18,sensors+29
 263 00ec 822B      		or r24,r18
 264 00ee 9F93      		push r25
 265 00f0 8F93      		push r24
 266 00f2 FF92      		push r15
 267 00f4 EF92      		push r14
 268 00f6 1F93      		push r17
 269 00f8 0F93      		push r16
 270 00fa 0E94 0000 		call sprintf
 271               	.LVL30:
 229:proj1.c       **** 			printBuffer(buffer);
 272               		.loc 1 229 0
 273 00fe C801      		movw r24,r16
 274 0100 0E94 0000 		call printBuffer
 275               	.LVL31:
 230:proj1.c       **** 			sprintf(buffer,"Current: %i\n", (uint16_t)((sensors[SenCurr1] << 8)| sensors[SenCurr0]));
 276               		.loc 1 230 0
 277 0104 8091 0000 		lds r24,sensors+19
 278 0108 90E0      		ldi r25,0
 279 010a 982F      		mov r25,r24
 280 010c 8827      		clr r24
 281 010e 2091 0000 		lds r18,sensors+20
 282 0112 822B      		or r24,r18
 283 0114 9F93      		push r25
 284 0116 8F93      		push r24
 285 0118 DF92      		push r13
 286 011a CF92      		push r12
 287 011c 1F93      		push r17
 288 011e 0F93      		push r16
 289 0120 0E94 0000 		call sprintf
 290               	.LVL32:
 231:proj1.c       **** 			printBuffer(buffer);
 291               		.loc 1 231 0
 292 0124 C801      		movw r24,r16
 293 0126 0E94 0000 		call printBuffer
 294               	.LVL33:
 233:proj1.c       **** 			sei();			
 295               		.loc 1 233 0
 296               	/* #APP */
 297               	 ;  233 "proj1.c" 1
 298 012a 7894      		sei
 299               	 ;  0 "" 2
 234:proj1.c       **** 			setSerialDestination(SERIAL_CREATE);
 300               		.loc 1 234 0
 301               	/* #NOAPP */
 302 012c 81E0      		ldi r24,lo8(1)
 303 012e 0E94 0000 		call setSerialDestination
 304               	.LVL34:
 235:proj1.c       **** 			canPrint=0;
 305               		.loc 1 235 0
 306 0132 1092 0000 		sts canPrint,__zero_reg__
 307 0136 0FB6      		in __tmp_reg__,__SREG__
 308 0138 F894      		cli
 309 013a DEBF      		out __SP_H__,r29
 310 013c 0FBE      		out __SREG__,__tmp_reg__
 311 013e CDBF      		out __SP_L__,r28
 312               	.L10:
 313               	.LBE5:
 237:proj1.c       **** 		delayMs(15);
 314               		.loc 1 237 0
 315 0140 8FE0      		ldi r24,lo8(15)
 316 0142 90E0      		ldi r25,0
 317 0144 0E94 0000 		call delayMs
 318               	.LVL35:
 238:proj1.c       **** 		if(UserButtonPressed) {
 319               		.loc 1 238 0
 320 0148 4C99      		sbic 0x9,4
 321 014a 00C0      		rjmp .L12
 239:proj1.c       **** 			powerOffRobot();
 322               		.loc 1 239 0
 323 014c 0E94 0000 		call powerOffRobot
 324               	.LVL36:
 240:proj1.c       **** 			exit(1);
 325               		.loc 1 240 0
 326 0150 81E0      		ldi r24,lo8(1)
 327 0152 90E0      		ldi r25,0
 328 0154 0E94 0000 		call exit
 329               	.LVL37:
 330               		.cfi_endproc
 331               	.LFE1:
 333               		.comm	sensors,52,1
 334               	.global	false
 335               		.section .bss
 338               	false:
 339 0000 0000      		.zero	2
 340               	.global	true
 341               		.data
 344               	true:
 345 0000 0100      		.word	1
 346               	.global	PI
 349               	PI:
 350 0002 DB        		.byte	-37
 351 0003 0F        		.byte	15
 352 0004 49        		.byte	73
 353 0005 40        		.byte	64
 354               		.comm	notReadyBool,1,1
 355               		.comm	DELAY,2,1
 356               		.text
 357               	.Letext0:
 358               		.file 2 "/usr/lib/avr/include/stdint.h"
 359               		.file 3 "timer.h"
 360               		.file 4 "cmod.h"
 361               		.file 5 "iroblib.h"
 362               		.file 6 "/usr/lib/avr/include/stdio.h"
 363               		.file 7 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 proj1.c
     /tmp/ccTKCGHP.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccTKCGHP.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccTKCGHP.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccTKCGHP.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccTKCGHP.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccTKCGHP.s:12     .text:0000000000000000 printBuffer
     /tmp/ccTKCGHP.s:90     .text.startup:0000000000000000 main
                            *COM*:0000000000000002 DELAY
                            *COM*:0000000000000001 notReadyBool
                            *COM*:0000000000000034 sensors
     /tmp/ccTKCGHP.s:338    .bss:0000000000000000 false
     /tmp/ccTKCGHP.s:344    .data:0000000000000000 true
     /tmp/ccTKCGHP.s:349    .data:0000000000000002 PI

UNDEFINED SYMBOLS
byteTx
initializeCommandModule
powerOnRobot
baud
defineSongs
delayMs
canSense
byteRx
senseTimerCount
canPrint
setSerialDestination
sprintf
powerOffRobot
exit
__do_copy_data
__do_clear_bss
